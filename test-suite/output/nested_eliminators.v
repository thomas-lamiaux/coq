(* Some prelude to be able to test the file without being able to compile the prelude *)

Notation "A -> B" := (forall (_ : A), B) (right associativity, at level 99).

Inductive nat : Type :=
| zero : nat
| S : nat -> nat.

Inductive bool : Type :=
| true : bool
| false : bool.

(* The type unit needs to be defined and registered to instantiate partial nesting. *)
Inductive unit : Set :=
    tt : unit.

Register unit as core.unit.type.
Register tt as core.unit.tt.

Set Printing Universes.

Module Template.

  (* Example with Template Inductive Types *)

  (* Example with list *)
  Inductive list (A : Type) : Type :=
  | nil : list A
  | cons : A -> list A -> list A.

  Arguments nil {_}.
  Arguments cons {_}.

  Infix "::" := cons (at level 60, right associativity) : list_scope.

  #[universes(polymorphic)]
  Inductive list_all@{sP; uP+} A (PA : A -> Type@{sP;uP}) : list A -> Type :=
  | nil_all : list_all A PA nil
  | cons_all : forall H : A, PA H -> forall H0 : list A, list_all A PA H0 -> list_all A PA (cons H H0).

  #[universes(polymorphic)]
  Definition list_all_forall@{sP; uP+} A (PA : A -> Type@{sP;uP}) (HPA : forall pA : A, PA pA) :=
    fix F0_list (x : list A) : list_all A PA x :=
    match x as H return (list_all A PA H) with
    | nil => nil_all A PA
    | cons x0 x1 => cons_all A PA x0 (HPA x0) x1 (F0_list x1)
    end.

  (* register the sparse paremetricity and the local fundamental theorem *)
  Register Scheme list_all as All for list.
  Register Scheme list_all_forall as AllForall for list.

  Inductive MRT : Set :=
  | MRTnode : list MRT -> MRT.

  About MRT_ind.

  Inductive RoseTree A : Type :=
  | RTleaf (a : A) : RoseTree A
  | RTnode (l : list (RoseTree A)) : RoseTree A.

  About RoseTree_ind.

  Inductive RoseRoseTree A : Type :=
  | Nleaf (a : A) : RoseRoseTree A
  | Nnode (p : (list (list (RoseRoseTree A)))) : RoseRoseTree A.

  About RoseRoseTree_ind.

  Inductive ArrowTree1 A : Type :=
  | ATleaf1 (a : A) : ArrowTree1 A
  | ATnode1 (l : (bool -> list (ArrowTree1 A))) : ArrowTree1 A.

  About ArrowTree1_ind.

  Inductive ArrowTree2 A : Type :=
  | ATleaf2 (a : A) : ArrowTree2 A
  | ATnode2 (l : list (nat -> ArrowTree2 A)) : ArrowTree2 A.

  About ArrowTree2_ind.

  Inductive ArrowTree3 A : Type :=
  | ATleaf3 (a : A) : ArrowTree3 A
  | ATnode3 (l : (bool -> list (nat -> ArrowTree3 A))) : ArrowTree3 A.

  About ArrowTree3_ind.

  (* Example Prod *)
  Inductive prod (A B : Type) : Type :=
    pair : A -> B -> prod A B.

  Arguments pair {_ _}.

  #[universes(polymorphic)]
  Inductive prod_all@{sa sb ; ua ub +} A (PA : A -> Type@{sa;ua}) B (PB : B -> Type@{sb;ub}) : prod A B -> Type :=
    pair_all : forall a, PA a -> forall b, PB b -> prod_all A PA B PB (pair a b).

  #[universes(polymorphic)]
  Definition prod_all_forall@{sa sb ; ua ub +} A (PA : A -> Type@{sa;ua}) (HPA : forall a, PA a)
                        B (PB : B -> Type@{sb;ub}) (HPB : forall b, PB b) :
                        forall (x : prod A B), prod_all A PA B PB x :=
    fun x => match x with
    | pair a b => pair_all A PA B PB a (HPA a) b (HPB b)
    end.

  Register Scheme prod_all as All for prod.
  Register Scheme prod_all_forall as AllForall for prod.

  Inductive PairTree A : Type :=
  | Pleaf (a : A) : PairTree A
  | Pnode (p : prod (PairTree A) (PairTree A)) : PairTree A.

  About PairTree_ind.

  Module AutoGeneratedScheme.

    Inductive LeftTree A : Type :=
    | Lleaf (a : A) : LeftTree A
    | Lnode (p : prod (LeftTree A) nat) : LeftTree A.

    About LeftTree_ind.

  End AutoGeneratedScheme.

  Module Scheme.

    Unset Elimination Schemes.

    Inductive LeftTree A : Type :=
    | Lleaf (a : A) : LeftTree A
    | Lnode (p : prod (LeftTree A) nat) : LeftTree A.

    Scheme Induction for LeftTree Sort Prop.

    About LeftTree_ind.

  End Scheme.

  Module PartialAll.

    #[universes(polymorphic)]
    Inductive prod_all_10@{sa; ua+} A (PA : A -> Type@{sa;ua}) B : prod A B -> Type :=
      pair_all_10 : forall a, PA a -> forall b, prod_all_10 A PA B (pair a b).

    #[universes(polymorphic)]
    Definition prod_all_forall_10@{sa; ua+} A (PA : A -> Type@{sa;ua}) (HPA : forall a, PA a) B :
                          forall (x : prod A B), prod_all_10 A PA B x :=
      fun x => match x with
      | pair a b => pair_all_10 A PA B a (HPA a) b
      end.

    Register Scheme prod_all_10 as All_10 for prod.
    Register Scheme prod_all_forall_10 as AllForall_10 for prod.

    Inductive LeftTree A : Type :=
    | Lleaf (a : A) : LeftTree A
    | Lnode (p : prod (LeftTree A) nat) : LeftTree A.

    About LeftTree_ind.

  End PartialAll.

  Inductive RightTree A : Type :=
  | Rleaf (a : A) : RightTree A
  | Rnode (p : prod nat (RightTree A)) : RightTree A.

  About RightTree_ind.

  (* Nesting with vec *)
  Inductive vec A : nat -> Type :=
  | vnil : vec A zero
  | vcons : A -> forall n, vec A n -> vec A (S n).

  #[universes(polymorphic)]
  Inductive vec_all@{s;ua+} A (P : A -> Type@{s;ua}) : forall n, vec A n -> Type :=
  | vnil_all  : vec_all A P zero (@vnil A)
  | vcons_all : forall a, P a -> forall n,
            forall v, vec_all A P n v ->
            vec_all A P (S n) (vcons _ a n v).

  #[universes(polymorphic)]
  Fixpoint vec_all_forall@{s;ua+} A (PA : A -> Type@{s;ua}) (HPA : forall a : A, PA a)
              n v : vec_all A PA n v :=
    match v with
    | vnil _ => vnil_all A PA
    | vcons _ a n v => vcons_all A PA a (HPA a) n v (vec_all_forall A PA HPA n v)
    end.

  Register Scheme vec_all as All for vec.
  Register Scheme vec_all_forall as AllForall for vec.

  Inductive VecTree A : Type :=
  | VNleaf (a : A) : VecTree A
  | VNnode n (p : vec (VecTree A) n) : VecTree A.

  About VecTree_ind.



  (* Example All2i *)
  Inductive All2i (A B : Type) (R : nat -> A -> B -> Type) (n : nat) : list A -> list B -> Type :=
    | All2i_nil : All2i A B R n nil nil
    | All2i_cons : forall (a : A) (b : B) (lA : list A) (lB : list B),
                  R n a b -> All2i A B R (S n) lA lB -> All2i A B R n (cons a lA) (cons b lB).

  Arguments All2i_nil {_ _ _ _ }.
  Arguments All2i_cons {_ _ _ _}.

  #[universes(polymorphic)]
  Inductive All2i_all@{sr;ur+} (A B : Type) (R : nat -> A -> B -> Type) (PR : forall n a b, R n a b -> Type@{sr;ur})
                (n : nat) : forall (lA : list A) (lB : list B), All2i A B R n lA lB -> Type :=
  | All2i_nil_all : All2i_all A B R PR n nil nil All2i_nil
  | All2i_cons_all : forall (a : A) (b : B) (lA : list A) (lB : list B),
                        forall (r : R n a b), PR n a b r ->
                        forall (al : All2i A B R (S n) lA lB), All2i_all A B R PR (S n) lA lB al ->
                        All2i_all A B R PR n (cons a lA) (cons b lB) (All2i_cons a b lA lB r al).

  Arguments All2i_nil_all {_ _ _ _ _}.
  Arguments All2i_cons_all {_ _ _ _ _}.

  #[universes(polymorphic)]
  Definition All2i_all_forall@{sr;ur+} (A B : Type) (R : nat -> A -> B -> Type)
    (PR : forall n a b, R n a b -> Type@{sr;ur}) (HPR : forall n a b r, PR n a b r) :
    forall n la lb x, All2i_all A B R PR n la lb x :=
    fix f n la lb x : All2i_all A B R PR n la lb x :=
    match x with
    | All2i_nil => All2i_nil_all
    | All2i_cons a b lA lB r x => All2i_cons_all a b lA lB r (HPR n a b r) x (f (S n) lA lB x)
    end.

  Register Scheme All2i_all as All for All2i.
  Register Scheme All2i_all_forall as AllForall for All2i.

  Inductive typing A B (n : nat) (a : A) (b : B) : Type :=
  | typ_nil  : typing A B n a b
  | typ_cons : forall (lA : list A) (lB : list B),
              All2i A B (fun n => typing A B n) n lA lB -> typing A B n a b.

  About typing_ind.


  (* Example All2i_bis_bis with trivial nesting on R *)
  Inductive All2i_bis (A B C : Type) (R : nat -> A -> B -> Type) (n : nat) : list A -> list B -> Type :=
    | All2i_bis_nil : C -> All2i_bis A B C R n nil nil
    | All2i_bis_cons : forall (a : A) (b : B) (lA : list A) (lB : list B),
                  R n a b -> All2i_bis A B C R (S n) lA lB -> All2i_bis A B C R n (cons a lA) (cons b lB).

  Arguments All2i_bis_nil  {_ _ _ _ _}.
  Arguments All2i_bis_cons {_ _ _ _ _}.

  #[universes(polymorphic)]
  Inductive All2i_bis_all@{sc sr ; uc ur+} (A B C : Type) (PC : C -> Type@{sc;uc})
              (R : nat -> A -> B -> Type) (PR : forall n a b, R n a b -> Type@{sr;ur})
              (n : nat) : forall (lA : list A) (lB : list B), All2i_bis A B C R n lA lB -> Type :=
  | All2i_bis_nil_all : forall c, PC c -> All2i_bis_all A B C PC R PR n nil nil (All2i_bis_nil c)
  | All2i_bis_cons_all : forall (a : A) (b : B) (lA : list A) (lB : list B),
                        forall (r : R n a b), PR n a b r ->
                        forall (al : All2i_bis A B C R (S n) lA lB), All2i_bis_all A B C PC R PR (S n) lA lB al ->
                        All2i_bis_all A B C PC R PR n (cons a lA) (cons b lB) (All2i_bis_cons a b lA lB r al).

  Arguments All2i_bis_nil_all  {_ _ _ _ _ _ _}.
  Arguments All2i_bis_cons_all {_ _ _ _ _ _ _}.

  #[universes(polymorphic)]
  Definition All2i_bis_all_forall@{sc sr ; uc ur+} (A B C : Type) (PC : C -> Type@{sc;uc}) (HPC : forall c, PC c) (R : nat -> A -> B -> Type)
    (PR : forall n a b, R n a b -> Type@{sr;ur}) (HPR : forall n a b r, PR n a b r) :
    forall n la lb x, All2i_bis_all A B C PC R PR n la lb x :=
    fix f n la lb x : All2i_bis_all A B C PC R PR n la lb x :=
    match x with
    | All2i_bis_nil c => All2i_bis_nil_all c (HPC c)
    | All2i_bis_cons a b lA lB r x => All2i_bis_cons_all a b lA lB r (HPR n a b r) x (f (S n) lA lB x)
    end.

  Register Scheme All2i_bis_all as All for All2i_bis.
  Register Scheme All2i_bis_all_forall as AllForall for All2i_bis.

  Inductive triv_All2_bis : Type :=
  | ctriv_All2_bis : All2i_bis bool bool triv_All2_bis (fun _ _ _ => nat) zero (@nil bool) (@nil bool) ->
                    triv_All2_bis.

  About triv_All2_bis_ind.

End Template.


Module UnivPoly.

  (* Example with Template Inductive Types *)

   Set Universe Polymorphism.

  (* Example with list *)
  Inductive list (A : Type) : Type :=
  | nil : list A
  | cons : A -> list A -> list A.

  Arguments nil {_}.
  Arguments cons {_}.

  Infix "::" := cons (at level 60, right associativity) : list_scope.

  #[universes(polymorphic)]
  Inductive list_all@{sP; uP+} A (PA : A -> Type@{sP;uP}) : list A -> Type :=
  | nil_all : list_all A PA nil
  | cons_all : forall H : A, PA H -> forall H0 : list A, list_all A PA H0 -> list_all A PA (cons H H0).

  #[universes(polymorphic)]
  Definition list_all_forall@{sP; uP+} A (PA : A -> Type@{sP;uP}) (HPA : forall pA : A, PA pA) :=
    fix F0_list (x : list A) : list_all A PA x :=
    match x as H return (list_all A PA H) with
    | nil => nil_all A PA
    | cons x0 x1 => cons_all A PA x0 (HPA x0) x1 (F0_list x1)
    end.

  (* register the sparse paremetricity and the local fundamental theorem *)
  Register Scheme list_all as All for list.
  Register Scheme list_all_forall as AllForall for list.

  Inductive MRT : Set :=
  | MRTnode : list MRT -> MRT.

  About MRT_ind.

  Inductive RoseTree A : Type :=
  | RTleaf (a : A) : RoseTree A
  | RTnode (l : list (RoseTree A)) : RoseTree A.

  About RoseTree_ind.

  Inductive RoseRoseTree A : Type :=
  | Nleaf (a : A) : RoseRoseTree A
  | Nnode (p : (list (list (RoseRoseTree A)))) : RoseRoseTree A.

  Inductive ArrowTree3 A : Type :=
  | ATleaf3 (a : A) : ArrowTree3 A
  | ATnode3 (l : (bool -> list (nat -> ArrowTree3 A))) : ArrowTree3 A.

  About ArrowTree3_ind.

End UnivPoly.


Module SortPoly.

  (* Example with a sort polymorphic containers *)
  Set Universe Polymorphism.

  Inductive list@{sA;uA uR} (A : Type@{sA;uA}) : Type@{sA; uR} :=
  | nil : list A
  | cons : A -> list A -> list A.

  Arguments nil {_}.
  Arguments cons {_}.

  Infix "::" := cons (at level 60, right associativity) : list_scope.

  Inductive list_all@{sA sP; uA uP+} (A : Type@{sA; uA}) (PA : A -> Type@{sP;uP}) : list A -> Type@{sA;_} :=
  | nil_all : list_all A PA nil
  | cons_all : forall H : A, PA H -> forall H0 : list A, list_all A PA H0 -> list_all A PA (cons H H0).

  Definition list_all_forall@{sA sP; uA uP+} (A : Type@{sA; uA}) (PA : A -> Type@{sP;uP}) (HPA : forall pA : A, PA pA) :=
    fix F0_list (x : list A) : list_all A PA x :=
    match x as H return (list_all A PA H) with
    | nil => nil_all A PA
    | cons x0 x1 => cons_all A PA x0 (HPA x0) x1 (F0_list x1)
    end.

  (* register the sparse paremetricity and the local fundamental theorem *)
  Register Scheme list_all as All for list.
  Register Scheme list_all_forall as AllForall for list.

  Inductive MRT : Set :=
  | MRTnode : list MRT -> MRT.

  About MRT_ind.

  Inductive SRT : SProp :=
  | SRTnode : list SRT -> SRT.

  About SRT_sind.

End SortPoly.



Module TestWarning.

  Set Warnings "+register-all".

  Inductive list (A : Type) : Type :=
  | nil : list A
  | cons : A -> list A -> list A.

  Fail Inductive MRT : Set :=
  | MRTnode : list MRT -> MRT.

  Set Warnings "-register-all".

  Inductive MRT : Set :=
  | MRTnode : list MRT -> MRT.

  About MRT_ind.

End TestWarning.
