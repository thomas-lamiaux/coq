File "./output/nested_eliminators.v", line 30, characters 13-21:
The command has indeed failed with message:
The reference True_all was not found in the current environment.
Inductive
list_all@{α ; u u0} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : list A -> Type@{max(Set,u,u0)} :=
    nil_all : list_all@{α ; u u0} A PA (nil A)
  | cons_all : forall a : A,
               PA a ->
               forall l : list A,
               list_all@{α ; u u0} A PA l ->
               list_all@{α ; u u0} A PA (cons A a l).
(* α ; *u *u0 |=  *)

Arguments list_all A%_type_scope PA%_function_scope l
Arguments nil_all A%_type_scope PA%_function_scope
Arguments cons_all A%_type_scope PA%_function_scope a _ l _
list_all_forall@{α ; u u0} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) -> forall l : list A, list_all@{α ; u u0} A PA l
(* α ; u u0 |=  *)

list_all_forall is universe polymorphic
Arguments list_all_forall A%_type_scope (PA HPA)%_function_scope l
list_all_forall is transparent
Expands to: Constant nested_eliminators.Template.list_all_forall
Declared in library nested_eliminators, line 33, characters 2-88
Inductive
list_all_all@{α α0 ; u u0 u1} (A : Type@{u}) (PA : A -> Type@{α ; u0})
(PPA : forall a : A, PA a -> Type@{α0 ; u1})
  : forall l : list A, list_all@{α ; u u0} A PA l -> Type@{max(Set,u,u0,u1)} :=
    nil_all_all : list_all_all@{α α0 ; u u0 u1} A PA PPA 
                    (nil A) (nil_all@{α ; u u0} A PA)
  | cons_all_all : forall (a : A) (p : PA a),
                   PPA a p ->
                   forall (l : list A) (l0 : list_all@{α ; u u0} A PA l),
                   list_all_all@{α α0 ; u u0 u1} A PA PPA l l0 ->
                   list_all_all@{α α0 ; u u0 u1} A PA PPA 
                     (cons A a l) (cons_all@{α ; u u0} A PA a p l l0).
(* α α0 ; *u *u0 *u1 |=  *)

Arguments list_all_all A%_type_scope (PA PPA)%_function_scope l l0
Arguments nil_all_all A%_type_scope (PA PPA)%_function_scope
Arguments cons_all_all A%_type_scope (PA PPA)%_function_scope a p _ l l _
list_all_all_forall@{α α0 ; u u0 u1} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0})
  (PPA : forall a : A, PA a -> Type@{α0 ; u1}),
(forall (a : A) (p : PA a), PPA a p) ->
forall (l : list A) (l0 : list_all@{α ; u u0} A PA l),
list_all_all@{α α0 ; u u0 u1} A PA PPA l l0
(* α α0 ; u u0 u1 |=  *)

list_all_all_forall is universe polymorphic
Arguments list_all_all_forall A%_type_scope (PA PPA HPPA)%_function_scope 
  l l0
list_all_all_forall is transparent
Expands to: Constant nested_eliminators.Template.list_all_all_forall
Declared in library nested_eliminators, line 33, characters 2-88
MRT_ind :
forall P : MRT -> Prop,
(forall l : list MRT, list_all@{Prop ; Set Set} MRT P l -> P (MRTnode l)) ->
forall m : MRT, P m

MRT_ind is not universe polymorphic
Arguments MRT_ind (P MRTnode)%_function_scope m
MRT_ind is transparent
Expands to: Constant nested_eliminators.Template.MRT_ind
Declared in library nested_eliminators, line 45, characters 2-55
RoseTree_ind :
forall (A : Type@{RoseTree_ind.u0}) (P : RoseTree A -> Prop),
(forall a : A, P (RTleaf A a)) ->
(forall l : list (RoseTree A),
 list_all@{Prop ; RoseTree_ind.u1 Set} (RoseTree A) P l -> P (RTnode A l)) ->
forall r : RoseTree A, P r

RoseTree_ind is not universe polymorphic
Arguments RoseTree_ind A%_type_scope (P RTleaf RTnode)%_function_scope r
RoseTree_ind is transparent
Expands to: Constant nested_eliminators.Template.RoseTree_ind
Declared in library nested_eliminators, line 50, characters 2-113
Inductive
RoseTree_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : RoseTree A -> Type@{max(Set,u,u0,u1)} :=
    RTleaf_all : forall a : A,
                 PA a -> RoseTree_all@{α ; u u0 u1 u2} A PA (RTleaf A a)
  | RTnode_all : forall l : list (RoseTree A),
                 list_all@{Type ; u2 u1} (RoseTree A)
                   (RoseTree_all@{α ; u u0 u1 u2} A PA) l ->
                 RoseTree_all@{α ; u u0 u1 u2} A PA (RTnode A l).
(* α ; *u *u0 *u1 *u2 |= Set <= u1
                         Set <= u2
                         u <= u1
                         u <= u2
                         u0 <= u1
                         u2 <= u1 *)

Arguments RoseTree_all A%_type_scope PA%_function_scope r
Arguments RTleaf_all A%_type_scope PA%_function_scope a _
Arguments RTnode_all A%_type_scope PA%_function_scope l _
RoseTree_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall r : RoseTree A, RoseTree_all@{α ; u u0 u1 u2} A PA r
(* α ; u u0 u1 u2 |= Set <= u2
                     u <= u2
                     u0 <= u1
                     u2 <= u1 *)

RoseTree_all_forall is universe polymorphic
Arguments RoseTree_all_forall A%_type_scope (PA HPA)%_function_scope r
RoseTree_all_forall is transparent
Expands to: Constant nested_eliminators.Template.RoseTree_all_forall
Declared in library nested_eliminators, line 50, characters 2-113
Inductive
RoseTreeMut_all@{α ; u} (A : Type@{RoseTreeMut.u0}) 
(PA : A -> Type@{α ; u})
  : RoseTreeMut A -> Type@{max(Set,RoseTreeMut.u0,u)} :=
    node_mut_all : forall f : forest A,
                   forest_all@{α ; u} A PA f ->
                   RoseTreeMut_all@{α ; u} A PA (node_mut A f)
  with forest_all@{α ; u} (A : Type@{RoseTreeMut.u0})
       (PA : A -> Type@{α ; u})
         : forest A -> Type@{max(Set,RoseTreeMut.u0,u)} :=
    forest_nil_all : forest_all@{α ; u} A PA (forest_nil A)
  | forest_cons_all : forall a : A,
                      PA a ->
                      forall r : RoseTreeMut A,
                      RoseTreeMut_all@{α ; u} A PA r ->
                      forest_all@{α ; u} A PA (forest_cons A a r).
(* α ; *u |=  *)

Arguments RoseTreeMut_all A%_type_scope PA%_function_scope r
Arguments node_mut_all A%_type_scope PA%_function_scope f _
Arguments forest_all A%_type_scope PA%_function_scope f
Arguments forest_nil_all A%_type_scope PA%_function_scope
Arguments forest_cons_all A%_type_scope PA%_function_scope a _ r _
RoseTreeMut_all_forall@{α ; u} :
forall (A : Type@{RoseTreeMut.u0}) (PA : A -> Type@{α ; u}),
(forall a : A, PA a) ->
forall r : RoseTreeMut A, RoseTreeMut_all@{α ; u} A PA r
(* α ; u |=  *)

RoseTreeMut_all_forall is universe polymorphic
Arguments RoseTreeMut_all_forall A%_type_scope (PA HPA)%_function_scope r
RoseTreeMut_all_forall is transparent
Expands to: Constant nested_eliminators.Template.RoseTreeMut_all_forall
Declared in library nested_eliminators, line 58, characters 2-164
Inductive
RoseTreeMut_all_all@{α α0 ; u u0} (A : Type@{RoseTreeMut.u0})
(PA : A -> Type@{α ; u}) (PPA : forall a : A, PA a -> Type@{α0 ; u0})
  : forall r : RoseTreeMut A,
    RoseTreeMut_all@{α ; u} A PA r -> Type@{max(Set,RoseTreeMut.u0,u,u0)} :=
    node_mut_all_all : forall (f : forest A) (f0 : forest_all@{α ; u} A PA f),
                       forest_all_all@{α α0 ; u u0} A PA PPA f f0 ->
                       RoseTreeMut_all_all@{α α0 ; u u0} A PA PPA
                         (node_mut A f) (node_mut_all@{α ; u} A PA f f0)
  with forest_all_all@{α α0 ; u u0} (A : Type@{RoseTreeMut.u0})
       (PA : A -> Type@{α ; u}) (PPA : forall a : A, PA a -> Type@{α0 ; u0})
         : forall f : forest A,
           forest_all@{α ; u} A PA f -> Type@{max(Set,RoseTreeMut.u0,u,u0)} :=
    forest_nil_all_all : forest_all_all@{α α0 ; u u0} A PA PPA 
                           (forest_nil A) (forest_nil_all@{α ; u} A PA)
  | forest_cons_all_all : forall (a : A) (p : PA a),
                          PPA a p ->
                          forall (r : RoseTreeMut A)
                            (r0 : RoseTreeMut_all@{α ; u} A PA r),
                          RoseTreeMut_all_all@{α α0 ; u u0} A PA PPA r r0 ->
                          forest_all_all@{α α0 ; u u0} A PA PPA
                            (forest_cons A a r)
                            (forest_cons_all@{α ; u} A PA a p r r0).
(* α α0 ; *u *u0 |=  *)

Arguments RoseTreeMut_all_all A%_type_scope (PA PPA)%_function_scope r r0
Arguments node_mut_all_all A%_type_scope (PA PPA)%_function_scope f f _
Arguments forest_all_all A%_type_scope (PA PPA)%_function_scope f f0
Arguments forest_nil_all_all A%_type_scope (PA PPA)%_function_scope
Arguments forest_cons_all_all A%_type_scope (PA PPA)%_function_scope 
  a p _ r r _
RoseTreeMut_all_all_forall@{α α0 ; u u0} :
forall (A : Type@{RoseTreeMut.u0}) (PA : A -> Type@{α ; u})
  (PPA : forall a : A, PA a -> Type@{α0 ; u0}),
(forall (a : A) (p : PA a), PPA a p) ->
forall (r : RoseTreeMut A) (r0 : RoseTreeMut_all@{α ; u} A PA r),
RoseTreeMut_all_all@{α α0 ; u u0} A PA PPA r r0
(* α α0 ; u u0 |=  *)

RoseTreeMut_all_all_forall is universe polymorphic
Arguments RoseTreeMut_all_all_forall A%_type_scope
  (PA PPA HPPA)%_function_scope r r0
RoseTreeMut_all_all_forall is transparent
Expands to: Constant nested_eliminators.Template.RoseTreeMut_all_all_forall
Declared in library nested_eliminators, line 58, characters 2-164
Inductive
RoseTreeMut_all@{α ; u} (A : Type@{RoseTreeMut.u0}) 
(PA : A -> Type@{α ; u})
  : RoseTreeMut A -> Type@{max(Set,RoseTreeMut.u0,u)} :=
    node_mut_all : forall f : forest A,
                   forest_all@{α ; u} A PA f ->
                   RoseTreeMut_all@{α ; u} A PA (node_mut A f)
  with forest_all@{α ; u} (A : Type@{RoseTreeMut.u0})
       (PA : A -> Type@{α ; u})
         : forest A -> Type@{max(Set,RoseTreeMut.u0,u)} :=
    forest_nil_all : forest_all@{α ; u} A PA (forest_nil A)
  | forest_cons_all : forall a : A,
                      PA a ->
                      forall r : RoseTreeMut A,
                      RoseTreeMut_all@{α ; u} A PA r ->
                      forest_all@{α ; u} A PA (forest_cons A a r).
(* α ; *u |=  *)

Arguments RoseTreeMut_all A%_type_scope PA%_function_scope r
Arguments node_mut_all A%_type_scope PA%_function_scope f _
Arguments forest_all A%_type_scope PA%_function_scope f
Arguments forest_nil_all A%_type_scope PA%_function_scope
Arguments forest_cons_all A%_type_scope PA%_function_scope a _ r _
forest_all_forall@{α ; u} :
forall (A : Type@{RoseTreeMut.u0}) (PA : A -> Type@{α ; u}),
(forall a : A, PA a) -> forall f : forest A, forest_all@{α ; u} A PA f
(* α ; u |=  *)

forest_all_forall is universe polymorphic
Arguments forest_all_forall A%_type_scope (PA HPA)%_function_scope f
forest_all_forall is transparent
Expands to: Constant nested_eliminators.Template.forest_all_forall
Declared in library nested_eliminators, line 58, characters 2-164
Inductive
RoseTreeMut_all_all@{α α0 ; u u0} (A : Type@{RoseTreeMut.u0})
(PA : A -> Type@{α ; u}) (PPA : forall a : A, PA a -> Type@{α0 ; u0})
  : forall r : RoseTreeMut A,
    RoseTreeMut_all@{α ; u} A PA r -> Type@{max(Set,RoseTreeMut.u0,u,u0)} :=
    node_mut_all_all : forall (f : forest A) (f0 : forest_all@{α ; u} A PA f),
                       forest_all_all@{α α0 ; u u0} A PA PPA f f0 ->
                       RoseTreeMut_all_all@{α α0 ; u u0} A PA PPA
                         (node_mut A f) (node_mut_all@{α ; u} A PA f f0)
  with forest_all_all@{α α0 ; u u0} (A : Type@{RoseTreeMut.u0})
       (PA : A -> Type@{α ; u}) (PPA : forall a : A, PA a -> Type@{α0 ; u0})
         : forall f : forest A,
           forest_all@{α ; u} A PA f -> Type@{max(Set,RoseTreeMut.u0,u,u0)} :=
    forest_nil_all_all : forest_all_all@{α α0 ; u u0} A PA PPA 
                           (forest_nil A) (forest_nil_all@{α ; u} A PA)
  | forest_cons_all_all : forall (a : A) (p : PA a),
                          PPA a p ->
                          forall (r : RoseTreeMut A)
                            (r0 : RoseTreeMut_all@{α ; u} A PA r),
                          RoseTreeMut_all_all@{α α0 ; u u0} A PA PPA r r0 ->
                          forest_all_all@{α α0 ; u u0} A PA PPA
                            (forest_cons A a r)
                            (forest_cons_all@{α ; u} A PA a p r r0).
(* α α0 ; *u *u0 |=  *)

Arguments RoseTreeMut_all_all A%_type_scope (PA PPA)%_function_scope r r0
Arguments node_mut_all_all A%_type_scope (PA PPA)%_function_scope f f _
Arguments forest_all_all A%_type_scope (PA PPA)%_function_scope f f0
Arguments forest_nil_all_all A%_type_scope (PA PPA)%_function_scope
Arguments forest_cons_all_all A%_type_scope (PA PPA)%_function_scope 
  a p _ r r _
forest_all_all_forall@{α α0 ; u u0} :
forall (A : Type@{RoseTreeMut.u0}) (PA : A -> Type@{α ; u})
  (PPA : forall a : A, PA a -> Type@{α0 ; u0}),
(forall (a : A) (p : PA a), PPA a p) ->
forall (f : forest A) (f0 : forest_all@{α ; u} A PA f),
forest_all_all@{α α0 ; u u0} A PA PPA f f0
(* α α0 ; u u0 |=  *)

forest_all_all_forall is universe polymorphic
Arguments forest_all_all_forall A%_type_scope (PA PPA HPPA)%_function_scope 
  f f0
forest_all_all_forall is transparent
Expands to: Constant nested_eliminators.Template.forest_all_all_forall
Declared in library nested_eliminators, line 58, characters 2-164
RoseRoseTree_ind :
forall (A : Type@{RoseRoseTree_ind.u0}) (P : RoseRoseTree A -> Prop),
(forall a : A, P (Nleaf A a)) ->
(forall p : list (list (RoseRoseTree A)),
 list_all@{Type ; RoseRoseTree_ind.u1 RoseRoseTree_ind.u1}
   (list (RoseRoseTree A))
   (list_all@{Prop ; RoseRoseTree_ind.u1 Set} (RoseRoseTree A) P) p ->
 P (Nnode A p)) ->
forall r : RoseRoseTree A, P r

RoseRoseTree_ind is not universe polymorphic
Arguments RoseRoseTree_ind A%_type_scope (P Nleaf Nnode)%_function_scope r
RoseRoseTree_ind is transparent
Expands to: Constant nested_eliminators.Template.RoseRoseTree_ind
Declared in library nested_eliminators, line 74, characters 2-136
Inductive
RoseRoseTree_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : RoseRoseTree A -> Type@{max(Set,u,u0,u1)} :=
    Nleaf_all : forall a : A,
                PA a -> RoseRoseTree_all@{α ; u u0 u1 u2} A PA (Nleaf A a)
  | Nnode_all : forall p : list (list (RoseRoseTree A)),
                list_all@{Type ; u2 u1} (list (RoseRoseTree A))
                  (list_all@{Type ; u2 u1} (RoseRoseTree A)
                     (RoseRoseTree_all@{α ; u u0 u1 u2} A PA))
                  p ->
                RoseRoseTree_all@{α ; u u0 u1 u2} A PA (Nnode A p).
(* α ; *u *u0 =u1 =u2 |= Set <= u1
                         Set <= u2
                         u <= u1
                         u <= u2
                         u0 <= u1
                         u2 <= u1 *)

Arguments RoseRoseTree_all A%_type_scope PA%_function_scope r
Arguments Nleaf_all A%_type_scope PA%_function_scope a _
Arguments Nnode_all A%_type_scope PA%_function_scope p _
RoseRoseTree_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall r : RoseRoseTree A, RoseRoseTree_all@{α ; u u0 u1 u2} A PA r
(* α ; u u0 u1 u2 |= Set <= u2
                     u <= u2
                     u0 <= u1
                     u2 <= u1 *)

RoseRoseTree_all_forall is universe polymorphic
Arguments RoseRoseTree_all_forall A%_type_scope (PA HPA)%_function_scope r
RoseRoseTree_all_forall is transparent
Expands to: Constant nested_eliminators.Template.RoseRoseTree_all_forall
Declared in library nested_eliminators, line 74, characters 2-136
ArrowTree1_ind :
forall (A : Type@{ArrowTree1_ind.u0}) (P : ArrowTree1 A -> Prop),
(forall a : A, P (ATleaf1 A a)) ->
(forall l : bool -> list (ArrowTree1 A),
 (forall H : bool,
  list_all@{Prop ; ArrowTree1_ind.u1 Set} (ArrowTree1 A) P (l H)) ->
 P (ATnode1 A l)) ->
forall a : ArrowTree1 A, P a

ArrowTree1_ind is not universe polymorphic
Arguments ArrowTree1_ind A%_type_scope (P ATleaf1 ATnode1)%_function_scope a
ArrowTree1_ind is transparent
Expands to: Constant nested_eliminators.Template.ArrowTree1_ind
Declared in library nested_eliminators, line 82, characters 2-133
Inductive
ArrowTree1_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : ArrowTree1 A -> Type@{max(Set,u,u0,u1)} :=
    ATleaf1_all : forall a : A,
                  PA a -> ArrowTree1_all@{α ; u u0 u1 u2} A PA (ATleaf1 A a)
  | ATnode1_all : forall l : bool -> list (ArrowTree1 A),
                  (forall H : bool,
                   list_all@{Type ; u2 u1} (ArrowTree1 A)
                     (ArrowTree1_all@{α ; u u0 u1 u2} A PA) 
                     (l H)) ->
                  ArrowTree1_all@{α ; u u0 u1 u2} A PA (ATnode1 A l).
(* α ; *u *u0 *u1 *u2 |= Set <= u1
                         Set <= u2
                         u <= u1
                         u <= u2
                         u0 <= u1
                         u2 <= u1 *)

Arguments ArrowTree1_all A%_type_scope PA%_function_scope a
Arguments ATleaf1_all A%_type_scope PA%_function_scope a _
Arguments ATnode1_all A%_type_scope (PA l _)%_function_scope
ArrowTree1_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall a : ArrowTree1 A, ArrowTree1_all@{α ; u u0 u1 u2} A PA a
(* α ; u u0 u1 u2 |= Set <= u2
                     u <= u2
                     u0 <= u1
                     u2 <= u1 *)

ArrowTree1_all_forall is universe polymorphic
Arguments ArrowTree1_all_forall A%_type_scope (PA HPA)%_function_scope a
ArrowTree1_all_forall is transparent
Expands to: Constant nested_eliminators.Template.ArrowTree1_all_forall
Declared in library nested_eliminators, line 82, characters 2-133
ArrowTree2_ind :
forall (A : Type@{ArrowTree2_ind.u0}) (P : ArrowTree2 A -> Prop),
(forall a : A, P (ATleaf2 A a)) ->
(forall l : list (nat -> ArrowTree2 A),
 list_all@{Prop ; ArrowTree2_ind.u1 Set} (nat -> ArrowTree2 A)
   (fun H : nat -> ArrowTree2 A => forall H0 : nat, P (H H0)) l ->
 P (ATnode2 A l)) ->
forall a : ArrowTree2 A, P a

ArrowTree2_ind is not universe polymorphic
Arguments ArrowTree2_ind A%_type_scope (P ATleaf2 ATnode2)%_function_scope a
ArrowTree2_ind is transparent
Expands to: Constant nested_eliminators.Template.ArrowTree2_ind
Declared in library nested_eliminators, line 90, characters 2-130
Inductive
ArrowTree2_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : ArrowTree2 A -> Type@{max(Set,u,u0,u1)} :=
    ATleaf2_all : forall a : A,
                  PA a -> ArrowTree2_all@{α ; u u0 u1 u2} A PA (ATleaf2 A a)
  | ATnode2_all : forall l : list (nat -> ArrowTree2 A),
                  list_all@{Type ; u2 u1} (nat -> ArrowTree2 A)
                    (fun H : nat -> ArrowTree2 A =>
                     forall H0 : nat,
                     ArrowTree2_all@{α ; u u0 u1 u2} A PA (H H0))
                    l ->
                  ArrowTree2_all@{α ; u u0 u1 u2} A PA (ATnode2 A l).
(* α ; *u *u0 *u1 *u2 |= Set <= u1
                         Set <= u2
                         u <= u1
                         u <= u2
                         u0 <= u1
                         u2 <= u1 *)

Arguments ArrowTree2_all A%_type_scope PA%_function_scope a
Arguments ATleaf2_all A%_type_scope PA%_function_scope a _
Arguments ATnode2_all A%_type_scope PA%_function_scope l _
ArrowTree2_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall a : ArrowTree2 A, ArrowTree2_all@{α ; u u0 u1 u2} A PA a
(* α ; u u0 u1 u2 |= Set <= u2
                     u <= u2
                     u0 <= u1
                     u2 <= u1 *)

ArrowTree2_all_forall is universe polymorphic
Arguments ArrowTree2_all_forall A%_type_scope (PA HPA)%_function_scope a
ArrowTree2_all_forall is transparent
Expands to: Constant nested_eliminators.Template.ArrowTree2_all_forall
Declared in library nested_eliminators, line 90, characters 2-130
ArrowTree3_ind :
forall (A : Type@{ArrowTree3_ind.u0}) (P : ArrowTree3 A -> Prop),
(forall a : A, P (ATleaf3 A a)) ->
(forall l : bool -> list (nat -> ArrowTree3 A),
 (forall H : bool,
  list_all@{Prop ; ArrowTree3_ind.u1 Set} (nat -> ArrowTree3 A)
    (fun H0 : nat -> ArrowTree3 A => forall H1 : nat, P (H0 H1)) 
    (l H)) ->
 P (ATnode3 A l)) ->
forall a : ArrowTree3 A, P a

ArrowTree3_ind is not universe polymorphic
Arguments ArrowTree3_ind A%_type_scope (P ATleaf3 ATnode3)%_function_scope a
ArrowTree3_ind is transparent
Expands to: Constant nested_eliminators.Template.ArrowTree3_ind
Declared in library nested_eliminators, line 98, characters 2-140
Inductive
ArrowTree3_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : ArrowTree3 A -> Type@{max(Set,u,u0,u1)} :=
    ATleaf3_all : forall a : A,
                  PA a -> ArrowTree3_all@{α ; u u0 u1 u2} A PA (ATleaf3 A a)
  | ATnode3_all : forall l : bool -> list (nat -> ArrowTree3 A),
                  (forall H : bool,
                   list_all@{Type ; u2 u1} (nat -> ArrowTree3 A)
                     (fun H0 : nat -> ArrowTree3 A =>
                      forall H1 : nat,
                      ArrowTree3_all@{α ; u u0 u1 u2} A PA (H0 H1))
                     (l H)) ->
                  ArrowTree3_all@{α ; u u0 u1 u2} A PA (ATnode3 A l).
(* α ; *u *u0 *u1 *u2 |= Set <= u1
                         Set <= u2
                         u <= u1
                         u <= u2
                         u0 <= u1
                         u2 <= u1 *)

Arguments ArrowTree3_all A%_type_scope PA%_function_scope a
Arguments ATleaf3_all A%_type_scope PA%_function_scope a _
Arguments ATnode3_all A%_type_scope (PA l _)%_function_scope
ArrowTree3_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall a : ArrowTree3 A, ArrowTree3_all@{α ; u u0 u1 u2} A PA a
(* α ; u u0 u1 u2 |= Set <= u2
                     u <= u2
                     u0 <= u1
                     u2 <= u1 *)

ArrowTree3_all_forall is universe polymorphic
Arguments ArrowTree3_all_forall A%_type_scope (PA HPA)%_function_scope a
ArrowTree3_all_forall is transparent
Expands to: Constant nested_eliminators.Template.ArrowTree3_all_forall
Declared in library nested_eliminators, line 98, characters 2-140
Inductive
prod_all@{α α0 ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u1})
(B : Type@{u0}) (PB : B -> Type@{α0 ; u2})
  : prod A B -> Type@{max(u,u0,u1,u2)} :=
    pair_all : forall a : A,
               PA a ->
               forall b : B,
               PB b -> prod_all@{α α0 ; u u0 u1 u2} A PA B PB (pair A B a b).
(* α α0 ; *u *u0 *u1 *u2 |=  *)

Arguments prod_all A%_type_scope PA%_function_scope 
  B%_type_scope PB%_function_scope p
Arguments pair_all A%_type_scope PA%_function_scope 
  B%_type_scope PB%_function_scope a _ b _
prod_all_forall@{α α0 ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u1}),
(forall a : A, PA a) ->
forall (B : Type@{u0}) (PB : B -> Type@{α0 ; u2}),
(forall b : B, PB b) ->
forall p : prod A B, prod_all@{α α0 ; u u0 u1 u2} A PA B PB p
(* α α0 ; u u0 u1 u2 |=  *)

prod_all_forall is universe polymorphic
Arguments prod_all_forall A%_type_scope (PA HPA)%_function_scope
  B%_type_scope (PB HPB)%_function_scope p
prod_all_forall is transparent
Expands to: Constant nested_eliminators.Template.prod_all_forall
Declared in library nested_eliminators, line 108, characters 2-70
Inductive
prod_all_all@{α α0 α1 α2 ; u u0 u1 u2 u3 u4} (A : Type@{u})
(PA : A -> Type@{α ; u1}) (PPA : forall a : A, PA a -> Type@{α1 ; u3})
(B : Type@{u0}) (PB : B -> Type@{α0 ; u2})
(PPB : forall b : B, PB b -> Type@{α2 ; u4})
  : forall p : prod A B,
    prod_all@{α α0 ; u u0 u1 u2} A PA B PB p -> Type@{max(u,u0,u1,u2,u3,u4)} :=
    pair_all_all : forall (a : A) (p : PA a),
                   PPA a p ->
                   forall (b : B) (p0 : PB b),
                   PPB b p0 ->
                   prod_all_all@{α α0 α1 α2 ; u u0 u1 u2 u3 u4} A PA PPA B PB
                     PPB (pair A B a b)
                     (pair_all@{α α0 ; u u0 u1 u2} A PA B PB a p b p0).
(* α α0 α1 α2 ; *u *u0 *u1 *u2 *u3 *u4 |=  *)

Arguments prod_all_all A%_type_scope (PA PPA)%_function_scope 
  B%_type_scope (PB PPB)%_function_scope p p0
Arguments pair_all_all A%_type_scope (PA PPA)%_function_scope 
  B%_type_scope (PB PPB)%_function_scope a p _ b p 
  _
prod_all_all_forall@{α α0 α1 α2 ; u u0 u1 u2 u3 u4} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u1})
  (PPA : forall a : A, PA a -> Type@{α1 ; u3}),
(forall (a : A) (p : PA a), PPA a p) ->
forall (B : Type@{u0}) (PB : B -> Type@{α0 ; u2})
  (PPB : forall b : B, PB b -> Type@{α2 ; u4}),
(forall (b : B) (p : PB b), PPB b p) ->
forall (p : prod A B) (p0 : prod_all@{α α0 ; u u0 u1 u2} A PA B PB p),
prod_all_all@{α α0 α1 α2 ; u u0 u1 u2 u3 u4} A PA PPA B PB PPB p p0
(* α α0 α1 α2 ; u u0 u1 u2 u3 u4 |=  *)

prod_all_all_forall is universe polymorphic
Arguments prod_all_all_forall A%_type_scope (PA PPA HPPA)%_function_scope
  B%_type_scope (PB PPB HPPB)%_function_scope p p0
prod_all_all_forall is transparent
Expands to: Constant nested_eliminators.Template.prod_all_all_forall
Declared in library nested_eliminators, line 108, characters 2-70
PairTree_ind :
forall (A : Type@{PairTree_ind.u0}) (P : PairTree A -> Prop),
(forall a : A, P (Pleaf A a)) ->
(forall p : prod (PairTree A) (PairTree A),
 prod_all@{Prop Prop ; PairTree_ind.u1 PairTree_ind.u1 Set Set} 
   (PairTree A) P (PairTree A) P p ->
 P (Pnode A p)) ->
forall p : PairTree A, P p

PairTree_ind is not universe polymorphic
Arguments PairTree_ind A%_type_scope (P Pleaf Pnode)%_function_scope p
PairTree_ind is transparent
Expands to: Constant nested_eliminators.Template.PairTree_ind
Declared in library nested_eliminators, line 118, characters 2-124
Inductive
PairTree_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : PairTree A -> Type@{max(Set,u,u0,u1)} :=
    Pleaf_all : forall a : A,
                PA a -> PairTree_all@{α ; u u0 u1 u2} A PA (Pleaf A a)
  | Pnode_all : forall p : prod (PairTree A) (PairTree A),
                prod_all@{Type Type ; u2 u2 u1 u1} 
                  (PairTree A) (PairTree_all@{α ; u u0 u1 u2} A PA)
                  (PairTree A) (PairTree_all@{α ; u u0 u1 u2} A PA) p ->
                PairTree_all@{α ; u u0 u1 u2} A PA (Pnode A p).
(* α ; *u *u0 *u1 *u2 |= Set <= u1
                         Set <= u2
                         u <= u1
                         u <= u2
                         u0 <= u1
                         u2 <= u1 *)

Arguments PairTree_all A%_type_scope PA%_function_scope p
Arguments Pleaf_all A%_type_scope PA%_function_scope a _
Arguments Pnode_all A%_type_scope PA%_function_scope p _
PairTree_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall p : PairTree A, PairTree_all@{α ; u u0 u1 u2} A PA p
(* α ; u u0 u1 u2 |= Set <= u2
                     u <= u2
                     u0 <= u1
                     u2 <= u1 *)

PairTree_all_forall is universe polymorphic
Arguments PairTree_all_forall A%_type_scope (PA HPA)%_function_scope p
PairTree_all_forall is transparent
Expands to: Constant nested_eliminators.Template.PairTree_all_forall
Declared in library nested_eliminators, line 118, characters 2-124
LeftTree_ind :
forall (A : Type@{LeftTree_ind.u0}) (P : LeftTree A -> Prop),
(forall a : A, P (Lleaf A a)) ->
(forall p : prod (LeftTree A) nat,
 prod_all@{Prop Type ; LeftTree_ind.u1 Set Set Set} 
   (LeftTree A) P nat (fun _ : nat => unit) p ->
 P (Lnode A p)) ->
forall l : LeftTree A, P l

LeftTree_ind is not universe polymorphic
Arguments LeftTree_ind A%_type_scope (P Lleaf Lnode)%_function_scope l
LeftTree_ind is transparent
Expands to: Constant
            nested_eliminators.Template.AutoGeneratedScheme.LeftTree_ind
Declared in library nested_eliminators, line 128, characters 4-121
Inductive
LeftTree_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : LeftTree A -> Type@{max(Set,u,u0,u1)} :=
    Lleaf_all : forall a : A,
                PA a -> LeftTree_all@{α ; u u0 u1 u2} A PA (Lleaf A a)
  | Lnode_all : forall p : prod (LeftTree A) nat,
                prod_all@{Type Type ; u2 Set u1 Set} 
                  (LeftTree A) (LeftTree_all@{α ; u u0 u1 u2} A PA) nat
                  (fun _ : nat => unit) p ->
                LeftTree_all@{α ; u u0 u1 u2} A PA (Lnode A p).
(* α ; *u *u0 *u1 *u2 |= Set <= u1
                         Set <= u2
                         u <= u1
                         u <= u2
                         u0 <= u1
                         u2 <= u1 *)

Arguments LeftTree_all A%_type_scope PA%_function_scope l
Arguments Lleaf_all A%_type_scope PA%_function_scope a _
Arguments Lnode_all A%_type_scope PA%_function_scope p _
LeftTree_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall l : LeftTree A, LeftTree_all@{α ; u u0 u1 u2} A PA l
(* α ; u u0 u1 u2 |= Set <= u2
                     u <= u2
                     u0 <= u1
                     u2 <= u1 *)

LeftTree_all_forall is universe polymorphic
Arguments LeftTree_all_forall A%_type_scope (PA HPA)%_function_scope l
LeftTree_all_forall is transparent
Expands to: Constant
            nested_eliminators.Template.AutoGeneratedScheme.LeftTree_all_forall
Declared in library nested_eliminators, line 128, characters 4-121
LeftTree_ind :
forall (A : Type@{LeftTree_ind.u0}) (P : LeftTree A -> Prop),
(forall a : A, P (Lleaf A a)) ->
(forall p : prod (LeftTree A) nat,
 prod_all@{Type Type ; LeftTree_ind.u1 Set Set Set} 
   (LeftTree A) P nat (fun _ : nat => unit) p ->
 P (Lnode A p)) ->
forall l : LeftTree A, P l

LeftTree_ind is not universe polymorphic
Arguments LeftTree_ind A%_type_scope (P Lleaf Lnode)%_function_scope l
LeftTree_ind is transparent
Expands to: Constant nested_eliminators.Template.Scheme.LeftTree_ind
Declared in library nested_eliminators, line 146, characters 4-44
Inductive
LeftTree_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : LeftTree A -> Type@{max(Set,u,u0,u1)} :=
    Lleaf_all : forall a : A,
                PA a -> LeftTree_all@{α ; u u0 u1 u2} A PA (Lleaf A a)
  | Lnode_all : forall p : prod (LeftTree A) nat,
                prod_all@{Type Type ; u2 Set u1 Set} 
                  (LeftTree A) (LeftTree_all@{α ; u u0 u1 u2} A PA) nat
                  (fun _ : nat => unit) p ->
                LeftTree_all@{α ; u u0 u1 u2} A PA (Lnode A p).
(* α ; *u *u0 *u1 *u2 |= Set <= u1
                         Set <= u2
                         u <= u1
                         u <= u2
                         u0 <= u1
                         u2 <= u1 *)

Arguments LeftTree_all A%_type_scope PA%_function_scope l
Arguments Lleaf_all A%_type_scope PA%_function_scope a _
Arguments Lnode_all A%_type_scope PA%_function_scope p _
LeftTree_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall l : LeftTree A, LeftTree_all@{α ; u u0 u1 u2} A PA l
(* α ; u u0 u1 u2 |= Set <= u2
                     u <= u2
                     u0 <= u1
                     u2 <= u1 *)

LeftTree_all_forall is universe polymorphic
Arguments LeftTree_all_forall A%_type_scope (PA HPA)%_function_scope l
LeftTree_all_forall is transparent
Expands to: Constant nested_eliminators.Template.Scheme.LeftTree_all_forall
Declared in library nested_eliminators, line 142, characters 4-121
Inductive
prod_all_10@{α ; u u0 u1} (A : Type@{u}) (PA : A -> Type@{α ; u1})
(B : Type@{u0}) : prod A B -> Type@{max(u,u0,u1)} :=
    pair_all_10 : forall a : A,
                  PA a ->
                  forall b : B, prod_all_10@{α ; u u0 u1} A PA B (pair a b).
(* α ; *u *u0 *u1 |=  *)

Arguments prod_all_10 A%_type_scope PA%_function_scope B%_type_scope p
Arguments pair_all_10 A%_type_scope PA%_function_scope B%_type_scope a _ b
prod_all_forall_10@{α ; u u0 u1} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u1}),
(forall a : A, PA a) ->
forall (B : Type@{u0}) (p : prod A B), prod_all_10@{α ; u u0 u1} A PA B p
(* α ; u u0 u1 |=  *)

prod_all_forall_10 is universe polymorphic
Arguments prod_all_forall_10 A%_type_scope (PA HPA)%_function_scope
  B%_type_scope p
prod_all_forall_10 is transparent
Expands to: Constant
            nested_eliminators.Template.PartialAll.prod_all_forall_10
Declared in library nested_eliminators, line 156, characters 4-31
Inductive
prod_all_10_all@{α α0 ; u u0 u1 u2} (A : Type@{u}) 
(PA : A -> Type@{α ; u1}) (PPA : forall a : A, PA a -> Type@{α0 ; u2})
(B : Type@{u0})
  : forall p : prod A B,
    prod_all_10@{α ; u u0 u1} A PA B p -> Type@{max(u,u0,u1,u2)} :=
    pair_all_10_all : forall (a : A) (p : PA a),
                      PPA a p ->
                      forall b : B,
                      prod_all_10_all@{α α0 ; u u0 u1 u2} A PA PPA B
                        (pair a b) (pair_all_10@{α ; u u0 u1} A PA B a p b).
(* α α0 ; *u *u0 *u1 *u2 |=  *)

Arguments prod_all_10_all A%_type_scope (PA PPA)%_function_scope
  B%_type_scope p p0
Arguments pair_all_10_all A%_type_scope (PA PPA)%_function_scope
  B%_type_scope a p _ b
prod_all_10_all_forall@{α α0 ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u1})
  (PPA : forall a : A, PA a -> Type@{α0 ; u2}),
(forall (a : A) (p : PA a), PPA a p) ->
forall (B : Type@{u0}) (p : prod A B)
  (p0 : prod_all_10@{α ; u u0 u1} A PA B p),
prod_all_10_all@{α α0 ; u u0 u1 u2} A PA PPA B p p0
(* α α0 ; u u0 u1 u2 |=  *)

prod_all_10_all_forall is universe polymorphic
Arguments prod_all_10_all_forall A%_type_scope (PA PPA HPPA)%_function_scope
  B%_type_scope p p0
prod_all_10_all_forall is transparent
Expands to: Constant
            nested_eliminators.Template.PartialAll.prod_all_10_all_forall
Declared in library nested_eliminators, line 156, characters 4-31
LeftTree_ind :
forall (A : Type@{LeftTree_ind.u0}) (P : LeftTree A -> Prop),
(forall a : A, P (Lleaf A a)) ->
(forall p : prod (LeftTree A) nat,
 prod_all_10@{Prop ; LeftTree_ind.u1 Set Set} (LeftTree A) P nat p ->
 P (Lnode A p)) ->
forall l : LeftTree A, P l

LeftTree_ind is not universe polymorphic
Arguments LeftTree_ind A%_type_scope (P Lleaf Lnode)%_function_scope l
LeftTree_ind is transparent
Expands to: Constant nested_eliminators.Template.PartialAll.LeftTree_ind
Declared in library nested_eliminators, line 162, characters 4-121
Inductive
LeftTree_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : LeftTree A -> Type@{max(Set,u,u0,u1)} :=
    Lleaf_all : forall a : A,
                PA a -> LeftTree_all@{α ; u u0 u1 u2} A PA (Lleaf A a)
  | Lnode_all : forall p : prod (LeftTree A) nat,
                prod_all_10@{Type ; u2 Set u1} (LeftTree A)
                  (LeftTree_all@{α ; u u0 u1 u2} A PA) nat p ->
                LeftTree_all@{α ; u u0 u1 u2} A PA (Lnode A p).
(* α ; *u *u0 *u1 *u2 |= Set <= u1
                         Set <= u2
                         u <= u1
                         u <= u2
                         u0 <= u1
                         u2 <= u1 *)

Arguments LeftTree_all A%_type_scope PA%_function_scope l
Arguments Lleaf_all A%_type_scope PA%_function_scope a _
Arguments Lnode_all A%_type_scope PA%_function_scope p _
LeftTree_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall l : LeftTree A, LeftTree_all@{α ; u u0 u1 u2} A PA l
(* α ; u u0 u1 u2 |= Set <= u2
                     u <= u2
                     u0 <= u1
                     u2 <= u1 *)

LeftTree_all_forall is universe polymorphic
Arguments LeftTree_all_forall A%_type_scope (PA HPA)%_function_scope l
LeftTree_all_forall is transparent
Expands to: Constant
            nested_eliminators.Template.PartialAll.LeftTree_all_forall
Declared in library nested_eliminators, line 162, characters 4-121
RightTree_ind :
forall (A : Type@{RightTree_ind.u0}) (P : RightTree A -> Prop),
(forall a : A, P (Rleaf A a)) ->
(forall p : prod nat (RightTree A),
 prod_all@{Type Prop ; Set RightTree_ind.u1 Set Set} nat
   (fun _ : nat => unit) (RightTree A) P p ->
 P (Rnode A p)) ->
forall r : RightTree A, P r

RightTree_ind is not universe polymorphic
Arguments RightTree_ind A%_type_scope (P Rleaf Rnode)%_function_scope r
RightTree_ind is transparent
Expands to: Constant nested_eliminators.Template.RightTree_ind
Declared in library nested_eliminators, line 172, characters 2-119
Inductive
RightTree_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : RightTree A -> Type@{max(Set,u,u0,u1)} :=
    Rleaf_all : forall a : A,
                PA a -> RightTree_all@{α ; u u0 u1 u2} A PA (Rleaf A a)
  | Rnode_all : forall p : prod nat (RightTree A),
                prod_all@{Type Type ; Set u2 Set u1} nat
                  (fun _ : nat => unit) (RightTree A)
                  (RightTree_all@{α ; u u0 u1 u2} A PA) p ->
                RightTree_all@{α ; u u0 u1 u2} A PA (Rnode A p).
(* α ; *u *u0 *u1 *u2 |= Set <= u1
                         Set <= u2
                         u <= u1
                         u <= u2
                         u0 <= u1
                         u2 <= u1 *)

Arguments RightTree_all A%_type_scope PA%_function_scope r
Arguments Rleaf_all A%_type_scope PA%_function_scope a _
Arguments Rnode_all A%_type_scope PA%_function_scope p _
RightTree_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall r : RightTree A, RightTree_all@{α ; u u0 u1 u2} A PA r
(* α ; u u0 u1 u2 |= Set <= u2
                     u <= u2
                     u0 <= u1
                     u2 <= u1 *)

RightTree_all_forall is universe polymorphic
Arguments RightTree_all_forall A%_type_scope (PA HPA)%_function_scope r
RightTree_all_forall is transparent
Expands to: Constant nested_eliminators.Template.RightTree_all_forall
Declared in library nested_eliminators, line 172, characters 2-119
Inductive
vec_all@{α ; u u0} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : forall n : nat, vec A n -> Type@{max(Set,u,u0)} :=
    vnil_all : vec_all@{α ; u u0} A PA zero (vnil A)
  | vcons_all : forall a : A,
                PA a ->
                forall (n : nat) (v : vec A n),
                vec_all@{α ; u u0} A PA n v ->
                vec_all@{α ; u u0} A PA (S n) (vcons A a n v).
(* α ; *u *u0 |=  *)

Arguments vec_all A%_type_scope PA%_function_scope n v
Arguments vnil_all A%_type_scope PA%_function_scope
Arguments vcons_all A%_type_scope PA%_function_scope a _ n v _
vec_all_forall@{α ; u u0} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall (n : nat) (v : vec A n), vec_all@{α ; u u0} A PA n v
(* α ; u u0 |=  *)

vec_all_forall is universe polymorphic
Arguments vec_all_forall A%_type_scope (PA HPA)%_function_scope n v
vec_all_forall is transparent
Expands to: Constant nested_eliminators.Template.vec_all_forall
Declared in library nested_eliminators, line 182, characters 2-107
Inductive
vec_all_all@{α α0 ; u u0 u1} (A : Type@{u}) (PA : A -> Type@{α ; u0})
(PPA : forall a : A, PA a -> Type@{α0 ; u1})
  : forall (n : nat) (v : vec A n),
    vec_all@{α ; u u0} A PA n v -> Type@{max(Set,u,u0,u1)} :=
    vnil_all_all : vec_all_all@{α α0 ; u u0 u1} A PA PPA zero 
                     (vnil A) (vnil_all@{α ; u u0} A PA)
  | vcons_all_all : forall (a : A) (p : PA a),
                    PPA a p ->
                    forall (n : nat) (v : vec A n)
                      (v0 : vec_all@{α ; u u0} A PA n v),
                    vec_all_all@{α α0 ; u u0 u1} A PA PPA n v v0 ->
                    vec_all_all@{α α0 ; u u0 u1} A PA PPA 
                      (S n) (vcons A a n v)
                      (vcons_all@{α ; u u0} A PA a p n v v0).
(* α α0 ; *u *u0 *u1 |=  *)

Arguments vec_all_all A%_type_scope (PA PPA)%_function_scope n v v0
Arguments vnil_all_all A%_type_scope (PA PPA)%_function_scope
Arguments vcons_all_all A%_type_scope (PA PPA)%_function_scope a p _ n v v _
vec_all_all_forall@{α α0 ; u u0 u1} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0})
  (PPA : forall a : A, PA a -> Type@{α0 ; u1}),
(forall (a : A) (p : PA a), PPA a p) ->
forall (n : nat) (v : vec A n) (v0 : vec_all@{α ; u u0} A PA n v),
vec_all_all@{α α0 ; u u0 u1} A PA PPA n v v0
(* α α0 ; u u0 u1 |=  *)

vec_all_all_forall is universe polymorphic
Arguments vec_all_all_forall A%_type_scope (PA PPA HPPA)%_function_scope 
  n v v0
vec_all_all_forall is transparent
Expands to: Constant nested_eliminators.Template.vec_all_all_forall
Declared in library nested_eliminators, line 182, characters 2-107
VecTree_ind :
forall (A : Type@{VecTree_ind.u0}) (P : VecTree A -> Prop),
(forall a : A, P (VNleaf A a)) ->
(forall (n : nat) (p : vec (VecTree A) n),
 vec_all@{Prop ; VecTree_ind.u1 Set} (VecTree A) P n p -> P (VNnode A n p)) ->
forall v : VecTree A, P v

VecTree_ind is not universe polymorphic
Arguments VecTree_ind A%_type_scope (P VNleaf VNnode)%_function_scope v
VecTree_ind is transparent
Expands to: Constant nested_eliminators.Template.VecTree_ind
Declared in library nested_eliminators, line 191, characters 2-112
Inductive
VecTree_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : VecTree A -> Type@{max(Set,u,u0,u1)} :=
    VNleaf_all : forall a : A,
                 PA a -> VecTree_all@{α ; u u0 u1 u2} A PA (VNleaf A a)
  | VNnode_all : forall (n : nat) (p : vec (VecTree A) n),
                 vec_all@{Type ; u2 u1} (VecTree A)
                   (VecTree_all@{α ; u u0 u1 u2} A PA) n p ->
                 VecTree_all@{α ; u u0 u1 u2} A PA (VNnode A n p).
(* α ; *u *u0 *u1 *u2 |= Set <= u1
                         Set <= u2
                         u <= u1
                         u <= u2
                         u0 <= u1
                         u2 <= u1 *)

Arguments VecTree_all A%_type_scope PA%_function_scope v
Arguments VNleaf_all A%_type_scope PA%_function_scope a _
Arguments VNnode_all A%_type_scope PA%_function_scope n p _
VecTree_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall v : VecTree A, VecTree_all@{α ; u u0 u1 u2} A PA v
(* α ; u u0 u1 u2 |= Set <= u2
                     u <= u2
                     u0 <= u1
                     u2 <= u1 *)

VecTree_all_forall is universe polymorphic
Arguments VecTree_all_forall A%_type_scope (PA HPA)%_function_scope v
VecTree_all_forall is transparent
Expands to: Constant nested_eliminators.Template.VecTree_all_forall
Declared in library nested_eliminators, line 191, characters 2-112
Inductive
All2i_all@{α ; u u0 u1 u2} (A : Type@{u}) (B : Type@{u0})
(R : nat -> A -> B -> Type@{u1})
(PR : forall (n : nat) (a : A) (b : B), R n a b -> Type@{α ; u2}) 
(n : nat)
  : forall (l : list A) (l0 : list B),
    All2i A B R n l l0 -> Type@{max(Set,u,u0,u1,u2)} :=
    All2i_nil_all : All2i_all@{α ; u u0 u1 u2} A B R PR n nil nil
                      (All2i_nil A B R n)
  | All2i_cons_all : forall (a : A) (b : B) (lA : list A) 
                       (lB : list B) (r : R n a b),
                     PR n a b r ->
                     forall a0 : All2i A B R (S n) lA lB,
                     All2i_all@{α ; u u0 u1 u2} A B R PR (S n) lA lB a0 ->
                     All2i_all@{α ; u u0 u1 u2} A B R PR n 
                       (cons a lA) (cons b lB)
                       (All2i_cons A B R n a b lA lB r a0).
(* α ; *u *u0 *u1 *u2 |=  *)

Arguments All2i_all (A B)%_type_scope (R PR)%_function_scope n l l a
Arguments All2i_nil_all (A B)%_type_scope (R PR)%_function_scope n
Arguments All2i_cons_all (A B)%_type_scope (R PR)%_function_scope 
  n a b lA lB r _ a _
All2i_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (B : Type@{u0}) (R : nat -> A -> B -> Type@{u1})
  (PR : forall (n : nat) (a : A) (b : B), R n a b -> Type@{α ; u2}),
(forall (n : nat) (a : A) (b : B) (r : R n a b), PR n a b r) ->
forall (n : nat) (l : list A) (l0 : list B) (a : All2i A B R n l l0),
All2i_all@{α ; u u0 u1 u2} A B R PR n l l0 a
(* α ; u u0 u1 u2 |=  *)

All2i_all_forall is universe polymorphic
Arguments All2i_all_forall (A B)%_type_scope (R PR HPR)%_function_scope 
  n l l a
All2i_all_forall is transparent
Expands to: Constant nested_eliminators.Template.All2i_all_forall
Declared in library nested_eliminators, line 202, characters 2-304
Inductive
All2i_all_all@{α α0 ; u u0 u1 u2 u3} (A : Type@{u}) 
(B : Type@{u0}) (R : nat -> A -> B -> Type@{u1})
(PR : forall (n : nat) (a : A) (b : B), R n a b -> Type@{α ; u2})
(PPR : forall (n : nat) (a : A) (b : B) (r : R n a b),
       PR n a b r -> Type@{α0 ; u3})
(n : nat)
  : forall (l : list A) (l0 : list B) (a : All2i A B R n l l0),
    All2i_all@{α ; u u0 u1 u2} A B R PR n l l0 a ->
    Type@{max(Set,u,u0,u1,u2,u3)} :=
    All2i_nil_all_all : All2i_all_all@{α α0 ; u u0 u1 u2 u3} A B R PR PPR n
                          nil nil (All2i_nil A B R n)
                          (All2i_nil_all@{α ; u u0 u1 u2} A B R PR n)
  | All2i_cons_all_all : forall (a : A) (b : B) (lA : list A) 
                           (lB : list B) (r : R n a b) 
                           (p : PR n a b r),
                         PPR n a b r p ->
                         forall (a0 : All2i A B R (S n) lA lB)
                           (a1 : All2i_all@{α ; u u0 u1 u2} A B R PR 
                                   (S n) lA lB a0),
                         All2i_all_all@{α α0 ; u u0 u1 u2 u3} A B R PR PPR
                           (S n) lA lB a0 a1 ->
                         All2i_all_all@{α α0 ; u u0 u1 u2 u3} A B R PR PPR n
                           (cons a lA) (cons b lB)
                           (All2i_cons A B R n a b lA lB r a0)
                           (All2i_cons_all@{α ; u u0 u1 u2} A B R PR n a b lA
                              lB r p a0 a1).
(* α α0 ; *u *u0 *u1 *u2 *u3 |=  *)

Arguments All2i_all_all (A B)%_type_scope (R PR PPR)%_function_scope 
  n l l a a0
Arguments All2i_nil_all_all (A B)%_type_scope (R PR PPR)%_function_scope n
Arguments All2i_cons_all_all (A B)%_type_scope (R PR PPR)%_function_scope 
  n a b lA lB r p _ a a _
All2i_all_all_forall@{α α0 ; u u0 u1 u2 u3} :
forall (A : Type@{u}) (B : Type@{u0}) (R : nat -> A -> B -> Type@{u1})
  (PR : forall (n : nat) (a : A) (b : B), R n a b -> Type@{α ; u2})
  (PPR : forall (n : nat) (a : A) (b : B) (r : R n a b),
         PR n a b r -> Type@{α0 ; u3}),
(forall (n : nat) (a : A) (b : B) (r : R n a b) (p : PR n a b r),
 PPR n a b r p) ->
forall (n : nat) (l : list A) (l0 : list B) (a : All2i A B R n l l0)
  (a0 : All2i_all@{α ; u u0 u1 u2} A B R PR n l l0 a),
All2i_all_all@{α α0 ; u u0 u1 u2 u3} A B R PR PPR n l l0 a a0
(* α α0 ; u u0 u1 u2 u3 |=  *)

All2i_all_all_forall is universe polymorphic
Arguments All2i_all_all_forall (A B)%_type_scope
  (R PR PPR HPPR)%_function_scope n l l a a0
All2i_all_all_forall is transparent
Expands to: Constant nested_eliminators.Template.All2i_all_all_forall
Declared in library nested_eliminators, line 202, characters 2-304
File "./output/nested_eliminators.v", line 212, characters 2-35:
The command has indeed failed with message:
The variable A is not included in the uniform parameters that are strictly positive and can be nested on.
Allowed parameters are R.
typing_ind :
forall (A : Type@{typing_ind.u0}) (B : Type@{typing_ind.u1})
  (P : forall (n : nat) (a : A) (b : B), typing A B n a b -> Prop),
(forall (n : nat) (a : A) (b : B), P n a b (typ_nil A B n a b)) ->
(forall (n : nat) (a : A) (b : B) (lA : list A) (lB : list B)
   (a0 : All2i A B (fun n0 : nat => typing A B n0) n lA lB),
 All2i_all@{Prop ; typing_ind.u0 typing_ind.u1 typing_ind.u2 Set} A B
   (fun (n0 : nat) (H : A) (H0 : B) => typing A B n0 H H0) P n lA lB a0 ->
 P n a b (typ_cons A B n a b lA lB a0)) ->
forall (n : nat) (a : A) (b : B) (t : typing A B n a b), P n a b t

typing_ind is not universe polymorphic
Arguments typing_ind (A B)%_type_scope (P typ_nil typ_cons)%_function_scope 
  n a b t
typing_ind is transparent
Expands to: Constant nested_eliminators.Template.typing_ind
Declared in library nested_eliminators, line 214, characters 2-218
Inductive
All2i_bis_all@{α α0 ; u u0 u1 u2 u3 u4} (A : Type@{u}) 
(B : Type@{u0}) (C : Type@{u1}) (PC : C -> Type@{α ; u3})
(R : nat -> A -> B -> Type@{u2})
(PR : forall (n : nat) (a : A) (b : B), R n a b -> Type@{α0 ; u4}) 
(n : nat)
  : forall (l : list A) (l0 : list B),
    All2i_bis A B C R n l l0 -> Type@{max(Set,u,u0,u1,u2,u3,u4)} :=
    All2i_bis_nil_all : forall c : C,
                        PC c ->
                        All2i_bis_all@{α α0 ; u u0 u1 u2 u3 u4} A B C PC R PR
                          n nil nil (All2i_bis_nil A B C R n c)
  | All2i_bis_cons_all : forall (a : A) (b : B) (lA : list A) 
                           (lB : list B) (r : R n a b),
                         PR n a b r ->
                         forall a0 : All2i_bis A B C R (S n) lA lB,
                         All2i_bis_all@{α α0 ; u u0 u1 u2 u3 u4} A B C PC R
                           PR (S n) lA lB a0 ->
                         All2i_bis_all@{α α0 ; u u0 u1 u2 u3 u4} A B C PC R
                           PR n (cons a lA) (cons b lB)
                           (All2i_bis_cons A B C R n a b lA lB r a0).
(* α α0 ; *u *u0 *u1 *u2 *u3 *u4 |=  *)

Arguments All2i_bis_all (A B C)%_type_scope (PC R PR)%_function_scope n l l a
Arguments All2i_bis_nil_all (A B C)%_type_scope (PC R PR)%_function_scope 
  n c _
Arguments All2i_bis_cons_all (A B C)%_type_scope (PC R PR)%_function_scope 
  n a b lA lB r _ a _
All2i_bis_all_forall@{α α0 ; u u0 u1 u2 u3 u4} :
forall (A : Type@{u}) (B : Type@{u0}) (C : Type@{u1})
  (PC : C -> Type@{α ; u3}),
(forall c : C, PC c) ->
forall (R : nat -> A -> B -> Type@{u2})
  (PR : forall (n : nat) (a : A) (b : B), R n a b -> Type@{α0 ; u4}),
(forall (n : nat) (a : A) (b : B) (r : R n a b), PR n a b r) ->
forall (n : nat) (l : list A) (l0 : list B) (a : All2i_bis A B C R n l l0),
All2i_bis_all@{α α0 ; u u0 u1 u2 u3 u4} A B C PC R PR n l l0 a
(* α α0 ; u u0 u1 u2 u3 u4 |=  *)

All2i_bis_all_forall is universe polymorphic
Arguments All2i_bis_all_forall (A B C)%_type_scope
  (PC HPC R PR HPR)%_function_scope n l l a
All2i_bis_all_forall is transparent
Expands to: Constant nested_eliminators.Template.All2i_bis_all_forall
Declared in library nested_eliminators, line 223, characters 2-341
Inductive
All2i_bis_all_all@{α α0 α1 α2 ; u u0 u1 u2 u3 u4 u5 u6} 
(A : Type@{u}) (B : Type@{u0}) (C : Type@{u1}) (PC : C -> Type@{α ; u3})
(PPC : forall c : C, PC c -> Type@{α1 ; u5}) (R : nat -> A -> B -> Type@{u2})
(PR : forall (n : nat) (a : A) (b : B), R n a b -> Type@{α0 ; u4})
(PPR : forall (n : nat) (a : A) (b : B) (r : R n a b),
       PR n a b r -> Type@{α2 ; u6})
(n : nat)
  : forall (l : list A) (l0 : list B) (a : All2i_bis A B C R n l l0),
    All2i_bis_all@{α α0 ; u u0 u1 u2 u3 u4} A B C PC R PR n l l0 a ->
    Type@{max(Set,u,u0,u1,u2,u3,u4,u5,u6)} :=
    All2i_bis_nil_all_all : forall (c : C) (p : PC c),
                            PPC c p ->
                            All2i_bis_all_all@{α α0 α1 α2 ; u u0 u1 u2 u3 u4
                              u5 u6} A B C PC PPC R PR PPR n nil nil
                              (All2i_bis_nil A B C R n c)
                              (All2i_bis_nil_all@{α α0 ; u u0 u1 u2 u3 u4} A
                                 B C PC R PR n c p)
  | All2i_bis_cons_all_all : forall (a : A) (b : B) 
                               (lA : list A) (lB : list B) 
                               (r : R n a b) (p : PR n a b r),
                             PPR n a b r p ->
                             forall (a0 : All2i_bis A B C R (S n) lA lB)
                               (a1 : All2i_bis_all@{α α0 ; u u0 u1 u2 u3 u4}
                                       A B C PC R PR 
                                       (S n) lA lB a0),
                             All2i_bis_all_all@{α α0 α1 α2 ; u u0 u1 u2 u3 u4
                               u5 u6} A B C PC PPC R PR PPR 
                               (S n) lA lB a0 a1 ->
                             All2i_bis_all_all@{α α0 α1 α2 ; u u0 u1 u2 u3 u4
                               u5 u6} A B C PC PPC R PR PPR n 
                               (cons a lA) (cons b lB)
                               (All2i_bis_cons A B C R n a b lA lB r a0)
                               (All2i_bis_cons_all@{α α0 ; u u0 u1 u2 u3 u4}
                                  A B C PC R PR n a b lA lB r p a0 a1).
(* α α0 α1 α2 ; *u *u0 *u1 *u2 *u3 *u4 *u5 *u6 |= 
    *)

Arguments All2i_bis_all_all (A B C)%_type_scope
  (PC PPC R PR PPR)%_function_scope n l l a a0
Arguments All2i_bis_nil_all_all (A B C)%_type_scope
  (PC PPC R PR PPR)%_function_scope n c p _
Arguments All2i_bis_cons_all_all (A B C)%_type_scope
  (PC PPC R PR PPR)%_function_scope n a b lA lB r 
  p _ a a _
All2i_bis_all_all_forall@{α α0 α1 α2 ; u u0 u1 u2 u3 u4 u5 u6} :
forall (A : Type@{u}) (B : Type@{u0}) (C : Type@{u1})
  (PC : C -> Type@{α ; u3}) (PPC : forall c : C, PC c -> Type@{α1 ; u5}),
(forall (c : C) (p : PC c), PPC c p) ->
forall (R : nat -> A -> B -> Type@{u2})
  (PR : forall (n : nat) (a : A) (b : B), R n a b -> Type@{α0 ; u4})
  (PPR : forall (n : nat) (a : A) (b : B) (r : R n a b),
         PR n a b r -> Type@{α2 ; u6}),
(forall (n : nat) (a : A) (b : B) (r : R n a b) (p : PR n a b r),
 PPR n a b r p) ->
forall (n : nat) (l : list A) (l0 : list B) (a : All2i_bis A B C R n l l0)
  (a0 : All2i_bis_all@{α α0 ; u u0 u1 u2 u3 u4} A B C PC R PR n l l0 a),
All2i_bis_all_all@{α α0 α1 α2 ; u u0 u1 u2 u3 u4 u5 u6} A B C PC PPC R PR PPR
  n l l0 a a0
(* α α0 α1 α2 ; u u0 u1 u2 u3 u4 u5 u6 |=  *)

All2i_bis_all_all_forall is universe polymorphic
Arguments All2i_bis_all_all_forall (A B C)%_type_scope
  (PC PPC HPPC R PR PPR HPPR)%_function_scope n l 
  l a a0
All2i_bis_all_all_forall is transparent
Expands to: Constant nested_eliminators.Template.All2i_bis_all_all_forall
Declared in library nested_eliminators, line 223, characters 2-341
triv_All2_bis_ind :
forall P : triv_All2_bis -> Prop,
(forall
   a : All2i_bis bool bool triv_All2_bis (fun (_ : nat) (_ _ : bool) => nat)
         zero nil nil,
 All2i_bis_all@{Prop Type ; Set Set Set Set Set Set} bool bool triv_All2_bis
   P (fun (_ : nat) (_ _ : bool) => nat)
   (fun (_ : nat) (_ _ : bool) (_ : nat) => unit) zero nil nil a ->
 P (ctriv_All2_bis a)) ->
forall t : triv_All2_bis, P t

triv_All2_bis_ind is not universe polymorphic
Arguments triv_All2_bis_ind (P ctriv_All2_bis)%_function_scope t
triv_All2_bis_ind is transparent
Expands to: Constant nested_eliminators.Template.triv_All2_bis_ind
Declared in library nested_eliminators, line 233, characters 2-176
Inductive
sig_all@{α α0 ; u u0 u1} (A : Type@{u}) (PA : A -> Type@{α ; u0})
(P : A -> Prop) (PP : forall a : A, P a -> Type@{α0 ; u1})
  : sig A P -> Type@{max(u,u0,u1)} :=
    exist_all : forall x : A,
                PA x ->
                forall p : P x,
                PP x p -> sig_all@{α α0 ; u u0 u1} A PA P PP (exist A P x p).
(* α α0 ; *u *u0 *u1 |=  *)

Arguments sig_all A%_type_scope (PA P PP)%_function_scope s
Arguments exist_all A%_type_scope (PA P PP)%_function_scope x _ p _
sig_all_forall@{α α0 ; u u0 u1} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall (P : A -> Prop) (PP : forall a : A, P a -> Type@{α0 ; u1}),
(forall (a : A) (p : P a), PP a p) ->
forall s : sig A P, sig_all@{α α0 ; u u0 u1} A PA P PP s
(* α α0 ; u u0 u1 |=  *)

sig_all_forall is universe polymorphic
Arguments sig_all_forall A%_type_scope (PA HPA P PP HPP)%_function_scope s
sig_all_forall is transparent
Expands to: Constant nested_eliminators.Template.sig_all_forall
Declared in library nested_eliminators, line 241, characters 2-94
Inductive
sig_all_10@{α ; u u0} (A : Type@{u}) (PA : A -> Type@{α ; u0})
(P : A -> Prop) : sig A P -> Type@{max(u,u0)} :=
    exist_all_10 : forall x : A,
                   PA x ->
                   forall p : P x,
                   sig_all_10@{α ; u u0} A PA P (exist A P x p).
(* α ; *u *u0 |=  *)

Arguments sig_all_10 A%_type_scope (PA P)%_function_scope s
Arguments exist_all_10 A%_type_scope (PA P)%_function_scope x _ p
sig_all_forall_10@{α ; u u0} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall (P : A -> Prop) (s : sig A P), sig_all_10@{α ; u u0} A PA P s
(* α ; u u0 |=  *)

sig_all_forall_10 is universe polymorphic
Arguments sig_all_forall_10 A%_type_scope (PA HPA P)%_function_scope s
sig_all_forall_10 is transparent
Expands to: Constant nested_eliminators.Template.sig_all_forall_10
Declared in library nested_eliminators, line 247, characters 2-28
Inductive
sig_all_01@{α ; u u0} (A : Type@{u}) (P : A -> Prop)
(PP : forall a : A, P a -> Type@{α ; u0}) : sig A P -> Type@{max(u,u0)} :=
    exist_all_01 : forall (x : A) (p : P x),
                   PP x p -> sig_all_01@{α ; u u0} A P PP (exist A P x p).
(* α ; *u *u0 |=  *)

Arguments sig_all_01 A%_type_scope (P PP)%_function_scope s
Arguments exist_all_01 A%_type_scope (P PP)%_function_scope x p _
sig_all_forall_01@{α ; u u0} :
forall (A : Type@{u}) (P : A -> Prop)
  (PP : forall a : A, P a -> Type@{α ; u0}),
(forall (a : A) (p : P a), PP a p) ->
forall s : sig A P, sig_all_01@{α ; u u0} A P PP s
(* α ; u u0 |=  *)

sig_all_forall_01 is universe polymorphic
Arguments sig_all_forall_01 A%_type_scope (P PP HPP)%_function_scope s
sig_all_forall_01 is transparent
Expands to: Constant nested_eliminators.Template.sig_all_forall_01
Declared in library nested_eliminators, line 251, characters 2-28
Inductive
NestRel_all@{α α0 ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u0})
(R : A -> A -> Prop) (PR : forall a a0 : A, R a a0 -> Type@{α0 ; u1})
  : NestRel A R -> Type@{max(u,u0,u1,u2)} :=
    mkR_all : forall x : A,
              PA x ->
              forall o : or (and (R x x) (R x x)) True,
              or_all@{Prop Type ; Set Set} (and (R x x) (R x x))
                (and_all@{α0 α0 ; u1 u1} (R x x) (PR x x) (R x x) (PR x x))
                True (fun _ : True => unit) o ->
              NestRel_all@{α α0 ; u u0 u1 u2} A PA R PR (mkR A R x o).
(* α α0 ; *u *u0 =u1 *u2 |=  *)

Arguments NestRel_all A%_type_scope (PA R PR)%_function_scope n
Arguments mkR_all A%_type_scope (PA R PR)%_function_scope x _ o _
NestRel_all_forall@{α α0 ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall (R : A -> A -> Prop) (PR : forall a a0 : A, R a a0 -> Type@{α0 ; u1}),
(forall (a a0 : A) (r : R a a0), PR a a0 r) ->
forall n : NestRel A R, NestRel_all@{α α0 ; u u0 u1 u2} A PA R PR n
(* α α0 ; u u0 u1 u2 |=  *)

NestRel_all_forall is universe polymorphic
Arguments NestRel_all_forall A%_type_scope (PA HPA R PR HPR)%_function_scope
  n
NestRel_all_forall is transparent
Expands to: Constant nested_eliminators.Template.NestRel_all_forall
Declared in library nested_eliminators, line 264, characters 2-111
File "./output/nested_eliminators.v", line 278, characters 4-26:
The command has indeed failed with message:
Not implemented for primitive records.
Inductive
ex_all@{α α0 ; u u0 u1} (A : Type@{u}) (PA : A -> Type@{α ; u0})
(P : A -> Prop) (PP : forall a : A, P a -> Type@{α0 ; u1})
  : ex A P -> Prop :=
    ex_intro_all : forall x : A,
                   PA x ->
                   forall p : P x,
                   PP x p ->
                   ex_all@{α α0 ; u u0 u1} A PA P PP (ex_intro A P x p).
(* α α0 ; *u *u0 *u1 |=  *)

Arguments ex_all A%_type_scope (PA P PP)%_function_scope e
Arguments ex_intro_all A%_type_scope (PA P PP)%_function_scope x _ p _
ex_all_forall@{α α0 ; u u0 u1} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) ->
forall (P : A -> Prop) (PP : forall a : A, P a -> Type@{α0 ; u1}),
(forall (a : A) (p : P a), PP a p) ->
forall e : ex A P, ex_all@{α α0 ; u u0 u1} A PA P PP e
(* α α0 ; u u0 u1 |=  *)

ex_all_forall is universe polymorphic
Arguments ex_all_forall A%_type_scope (PA HPA P PP HPP)%_function_scope e
ex_all_forall is transparent
Expands to: Constant nested_eliminators.Template.ex_all_forall
Declared in library nested_eliminators, line 284, characters 2-87
adequate_ind :
forall (L : language) (φ : unit -> Type@{adequate_ind.u0})
  (P : adequate L φ -> Prop),
(forall p : prod False (ex (expr L) (fun e2 : expr L => prim_step L e2)),
 P (cadequate L φ p)) ->
forall a : adequate L φ, P a

adequate_ind is not universe polymorphic
Arguments adequate_ind L (φ P cadequate)%_function_scope a
adequate_ind is transparent
Expands to: Constant nested_eliminators.Template.adequate_ind
Declared in library nested_eliminators, line 295, characters 2-131
adequate_all@{α ; u u0} :
forall (L : language) (φ : unit -> Type@{u}),
(forall u : unit, φ u -> Type@{α ; u0}) -> adequate L φ -> Prop
(* α ; *u *u0 |=  *)

adequate_all is universe polymorphic
Arguments adequate_all L (φ Pφ)%_function_scope a
Expands to: Inductive nested_eliminators.Template.adequate_all
Declared in library nested_eliminators, line 295, characters 2-131
File "./output/nested_eliminators.v", line 315, characters 13-21:
The command has indeed failed with message:
The reference True_all was not found in the current environment.
Inductive
list_all@{α ; u u0} (A : Type@{u}) (PA : A -> Type@{α ; u0})
  : list@{u} A -> Type@{max(Set,u,u0)} :=
    nil_all : list_all@{α ; u u0} A PA (nil@{u} A)
  | cons_all : forall a : A,
               PA a ->
               forall l : list@{u} A,
               list_all@{α ; u u0} A PA l ->
               list_all@{α ; u u0} A PA (cons@{u} A a l).
(* α ; =u *u0 |=  *)

Arguments list_all A%_type_scope PA%_function_scope l
Arguments nil_all A%_type_scope PA%_function_scope
Arguments cons_all A%_type_scope PA%_function_scope a _ l _
list_all_forall@{α ; u u0} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0}),
(forall a : A, PA a) -> forall l : list@{u} A, list_all@{α ; u u0} A PA l
(* α ; u u0 |=  *)

list_all_forall is universe polymorphic
Arguments list_all_forall A%_type_scope (PA HPA)%_function_scope l
list_all_forall is transparent
Expands to: Constant nested_eliminators.UnivPoly.list_all_forall
Declared in library nested_eliminators, line 318, characters 2-88
Inductive
list_all_all@{α α0 ; u u0 u1} (A : Type@{u}) (PA : A -> Type@{α ; u0})
(PPA : forall a : A, PA a -> Type@{α0 ; u1})
  : forall l : list@{u} A,
    list_all@{α ; u u0} A PA l -> Type@{max(Set,u,u0,u1)} :=
    nil_all_all : list_all_all@{α α0 ; u u0 u1} A PA PPA 
                    (nil@{u} A) (nil_all@{α ; u u0} A PA)
  | cons_all_all : forall (a : A) (p : PA a),
                   PPA a p ->
                   forall (l : list@{u} A) (l0 : list_all@{α ; u u0} A PA l),
                   list_all_all@{α α0 ; u u0 u1} A PA PPA l l0 ->
                   list_all_all@{α α0 ; u u0 u1} A PA PPA 
                     (cons@{u} A a l) (cons_all@{α ; u u0} A PA a p l l0).
(* α α0 ; =u *u0 *u1 |=  *)

Arguments list_all_all A%_type_scope (PA PPA)%_function_scope l l0
Arguments nil_all_all A%_type_scope (PA PPA)%_function_scope
Arguments cons_all_all A%_type_scope (PA PPA)%_function_scope a p _ l l _
list_all_all_forall@{α α0 ; u u0 u1} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u0})
  (PPA : forall a : A, PA a -> Type@{α0 ; u1}),
(forall (a : A) (p : PA a), PPA a p) ->
forall (l : list@{u} A) (l0 : list_all@{α ; u u0} A PA l),
list_all_all@{α α0 ; u u0 u1} A PA PPA l l0
(* α α0 ; u u0 u1 |=  *)

list_all_all_forall is universe polymorphic
Arguments list_all_all_forall A%_type_scope (PA PPA HPPA)%_function_scope 
  l l0
list_all_all_forall is transparent
Expands to: Constant nested_eliminators.UnivPoly.list_all_all_forall
Declared in library nested_eliminators, line 318, characters 2-88
MRT_ind@{} :
forall P : MRT -> Prop,
(forall l : list@{Set} MRT,
 list_all@{Prop ; Set Set} MRT P l -> P (MRTnode l)) ->
forall m : MRT, P m

MRT_ind is universe polymorphic
Arguments MRT_ind (P MRTnode)%_function_scope m
MRT_ind is transparent
Expands to: Constant nested_eliminators.UnivPoly.MRT_ind
Declared in library nested_eliminators, line 327, characters 2-55
RoseTree_ind@{u u0} :
forall (A : Type@{u}) (P : RoseTree@{u u0} A -> Prop),
(forall a : A, P (RTleaf@{u u0} A a)) ->
(forall l : list@{u0} (RoseTree@{u u0} A),
 list_all@{Prop ; u0 Set} (RoseTree@{u u0} A) P l -> P (RTnode@{u u0} A l)) ->
forall r : RoseTree@{u u0} A, P r
(* u u0 |= u <= u0 *)

RoseTree_ind is universe polymorphic
Arguments RoseTree_ind A%_type_scope (P RTleaf RTnode)%_function_scope r
RoseTree_ind is transparent
Expands to: Constant nested_eliminators.UnivPoly.RoseTree_ind
Declared in library nested_eliminators, line 332, characters 2-113
Inductive
RoseTree_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u1})
  : RoseTree@{u u0} A -> Type@{max(u0,u1,u2)} :=
    RTleaf_all : forall a : A,
                 PA a ->
                 RoseTree_all@{α ; u u0 u1 u2} A PA (RTleaf@{u u0} A a)
  | RTnode_all : forall l : list@{u0} (RoseTree@{u u0} A),
                 list_all@{Type ; u0 u2} (RoseTree@{u u0} A)
                   (RoseTree_all@{α ; u u0 u1 u2} A PA) l ->
                 RoseTree_all@{α ; u u0 u1 u2} A PA (RTnode@{u u0} A l).
(* α ; =u =u0 *u1 *u2 |= u <= u0
                         u0 <= u2
                         u1 <= u2 *)

Arguments RoseTree_all A%_type_scope PA%_function_scope r
Arguments RTleaf_all A%_type_scope PA%_function_scope a _
Arguments RTnode_all A%_type_scope PA%_function_scope l _
RoseTree_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u1}),
(forall a : A, PA a) ->
forall r : RoseTree@{u u0} A, RoseTree_all@{α ; u u0 u1 u2} A PA r
(* α ; u u0 u1 u2 |= u <= u0
                     u0 <= u2
                     u1 <= u2 *)

RoseTree_all_forall is universe polymorphic
Arguments RoseTree_all_forall A%_type_scope (PA HPA)%_function_scope r
RoseTree_all_forall is transparent
Expands to: Constant nested_eliminators.UnivPoly.RoseTree_all_forall
Declared in library nested_eliminators, line 332, characters 2-113
RoseRoseTree_ind@{u u0 u1} :
forall (A : Type@{u}) (P : RoseRoseTree@{u u0} A -> Prop),
(forall a : A, P (Nleaf@{u u0} A a)) ->
(forall p : list@{u0} (list@{u0} (RoseRoseTree@{u u0} A)),
 list_all@{Type ; u0 u1} (list@{u0} (RoseRoseTree@{u u0} A))
   (list_all@{Prop ; u0 Set} (RoseRoseTree@{u u0} A) P) p ->
 P (Nnode@{u u0} A p)) ->
forall r : RoseRoseTree@{u u0} A, P r
(* u u0 u1 |= Set <= u1
              u <= u0
              u0 <= u1 *)

RoseRoseTree_ind is universe polymorphic
Arguments RoseRoseTree_ind A%_type_scope (P Nleaf Nnode)%_function_scope r
RoseRoseTree_ind is transparent
Expands to: Constant nested_eliminators.UnivPoly.RoseRoseTree_ind
Declared in library nested_eliminators, line 340, characters 2-136
Inductive
RoseRoseTree_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u1})
  : RoseRoseTree@{u u0} A -> Type@{max(u0,u1,u2)} :=
    Nleaf_all : forall a : A,
                PA a ->
                RoseRoseTree_all@{α ; u u0 u1 u2} A PA (Nleaf@{u u0} A a)
  | Nnode_all : forall p : list@{u0} (list@{u0} (RoseRoseTree@{u u0} A)),
                list_all@{Type ; u0 u2} (list@{u0} (RoseRoseTree@{u u0} A))
                  (list_all@{Type ; u0 u2} (RoseRoseTree@{u u0} A)
                     (RoseRoseTree_all@{α ; u u0 u1 u2} A PA))
                  p ->
                RoseRoseTree_all@{α ; u u0 u1 u2} A PA (Nnode@{u u0} A p).
(* α ; =u =u0 *u1 =u2 |= Set <= u2
                         u <= u0
                         u0 <= u2
                         u1 <= u2 *)

Arguments RoseRoseTree_all A%_type_scope PA%_function_scope r
Arguments Nleaf_all A%_type_scope PA%_function_scope a _
Arguments Nnode_all A%_type_scope PA%_function_scope p _
RoseRoseTree_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u1}),
(forall a : A, PA a) ->
forall r : RoseRoseTree@{u u0} A, RoseRoseTree_all@{α ; u u0 u1 u2} A PA r
(* α ; u u0 u1 u2 |= Set <= u2
                     u <= u0
                     u0 <= u2
                     u1 <= u2 *)

RoseRoseTree_all_forall is universe polymorphic
Arguments RoseRoseTree_all_forall A%_type_scope (PA HPA)%_function_scope r
RoseRoseTree_all_forall is transparent
Expands to: Constant nested_eliminators.UnivPoly.RoseRoseTree_all_forall
Declared in library nested_eliminators, line 340, characters 2-136
ArrowTree3_ind@{u u0} :
forall (A : Type@{u}) (P : ArrowTree3@{u u0} A -> Prop),
(forall a : A, P (ATleaf3@{u u0} A a)) ->
(forall l : bool -> list@{u0} (nat -> ArrowTree3@{u u0} A),
 (forall H : bool,
  list_all@{Prop ; u0 Set} (nat -> ArrowTree3@{u u0} A)
    (fun H0 : nat -> ArrowTree3@{u u0} A => forall H1 : nat, P (H0 H1)) 
    (l H)) ->
 P (ATnode3@{u u0} A l)) ->
forall a : ArrowTree3@{u u0} A, P a
(* u u0 |= u <= u0 *)

ArrowTree3_ind is universe polymorphic
Arguments ArrowTree3_ind A%_type_scope (P ATleaf3 ATnode3)%_function_scope a
ArrowTree3_ind is transparent
Expands to: Constant nested_eliminators.UnivPoly.ArrowTree3_ind
Declared in library nested_eliminators, line 348, characters 2-140
Inductive
ArrowTree3_all@{α ; u u0 u1 u2} (A : Type@{u}) (PA : A -> Type@{α ; u1})
  : ArrowTree3@{u u0} A -> Type@{max(u0,u1,u2)} :=
    ATleaf3_all : forall a : A,
                  PA a ->
                  ArrowTree3_all@{α ; u u0 u1 u2} A PA (ATleaf3@{u u0} A a)
  | ATnode3_all : forall l : bool -> list@{u0} (nat -> ArrowTree3@{u u0} A),
                  (forall H : bool,
                   list_all@{Type ; u0 u2} (nat -> ArrowTree3@{u u0} A)
                     (fun H0 : nat -> ArrowTree3@{u u0} A =>
                      forall H1 : nat,
                      ArrowTree3_all@{α ; u u0 u1 u2} A PA (H0 H1))
                     (l H)) ->
                  ArrowTree3_all@{α ; u u0 u1 u2} A PA (ATnode3@{u u0} A l).
(* α ; =u =u0 *u1 *u2 |= Set <= u2
                         u <= u0
                         u0 <= u2
                         u1 <= u2 *)

Arguments ArrowTree3_all A%_type_scope PA%_function_scope a
Arguments ATleaf3_all A%_type_scope PA%_function_scope a _
Arguments ATnode3_all A%_type_scope (PA l _)%_function_scope
ArrowTree3_all_forall@{α ; u u0 u1 u2} :
forall (A : Type@{u}) (PA : A -> Type@{α ; u1}),
(forall a : A, PA a) ->
forall a : ArrowTree3@{u u0} A, ArrowTree3_all@{α ; u u0 u1 u2} A PA a
(* α ; u u0 u1 u2 |= Set <= u2
                     u <= u0
                     u0 <= u2
                     u1 <= u2 *)

ArrowTree3_all_forall is universe polymorphic
Arguments ArrowTree3_all_forall A%_type_scope (PA HPA)%_function_scope a
ArrowTree3_all_forall is transparent
Expands to: Constant nested_eliminators.UnivPoly.ArrowTree3_all_forall
Declared in library nested_eliminators, line 348, characters 2-140
Inductive
list_all@{α α0 ; u u0 u1} (A : Type@{α ; u}) (PA : A -> Type@{α0 ; u1})
  : list@{α ; u u0} A -> Type@{α ; max(u0,u1)} :=
    nil_all : list_all@{α α0 ; u u0 u1} A PA (nil@{α ; u u0} A)
  | cons_all : forall a : A,
               PA a ->
               forall l : list@{α ; u u0} A,
               list_all@{α α0 ; u u0 u1} A PA l ->
               list_all@{α α0 ; u u0 u1} A PA (cons@{α ; u u0} A a l).
(* α α0 ; =u =u0 *u1 |= u <= u0 *)

Arguments list_all A%_type_scope PA%_function_scope l
Arguments nil_all A%_type_scope PA%_function_scope
Arguments cons_all A%_type_scope PA%_function_scope a _ l _
list_all_forall@{α α0 ; u u0 u1} :
forall (A : Type@{α ; u}) (PA : A -> Type@{α0 ; u1}),
(forall a : A, PA a) ->
forall l : list@{α ; u u0} A, list_all@{α α0 ; u u0 u1} A PA l
(* α α0 ; u u0 u1 |= u <= u0 *)

list_all_forall is universe polymorphic
Arguments list_all_forall A%_type_scope (PA HPA)%_function_scope l
list_all_forall is transparent
Expands to: Constant nested_eliminators.SortPoly.list_all_forall
Declared in library nested_eliminators, line 366, characters 2-116
Inductive
list_all_all@{α α0 α1 ; u u0 u1 u2} (A : Type@{α ; u})
(PA : A -> Type@{α0 ; u1}) (PPA : forall a : A, PA a -> Type@{α1 ; u2})
  : forall l : list@{α ; u u0} A,
    list_all@{α α0 ; u u0 u1} A PA l -> Type@{α ; max(u0,u1,u2)} :=
    nil_all_all : list_all_all@{α α0 α1 ; u u0 u1 u2} A PA PPA
                    (nil@{α ; u u0} A) (nil_all@{α α0 ; u u0 u1} A PA)
  | cons_all_all : forall (a : A) (p : PA a),
                   PPA a p ->
                   forall (l : list@{α ; u u0} A)
                     (l0 : list_all@{α α0 ; u u0 u1} A PA l),
                   list_all_all@{α α0 α1 ; u u0 u1 u2} A PA PPA l l0 ->
                   list_all_all@{α α0 α1 ; u u0 u1 u2} A PA PPA
                     (cons@{α ; u u0} A a l)
                     (cons_all@{α α0 ; u u0 u1} A PA a p l l0).
(* α α0 α1 ; =u =u0 *u1 *u2 |= u <= u0 *)

Arguments list_all_all A%_type_scope (PA PPA)%_function_scope l l0
Arguments nil_all_all A%_type_scope (PA PPA)%_function_scope
Arguments cons_all_all A%_type_scope (PA PPA)%_function_scope a p _ l l _
list_all_all_forall@{α α0 α1 ; u u0 u1 u2} :
forall (A : Type@{α ; u}) (PA : A -> Type@{α0 ; u1})
  (PPA : forall a : A, PA a -> Type@{α1 ; u2}),
(forall (a : A) (p : PA a), PPA a p) ->
forall (l : list@{α ; u u0} A) (l0 : list_all@{α α0 ; u u0 u1} A PA l),
list_all_all@{α α0 α1 ; u u0 u1 u2} A PA PPA l l0
(* α α0 α1 ; u u0 u1 u2 |= u <= u0 *)

list_all_all_forall is universe polymorphic
Arguments list_all_all_forall A%_type_scope (PA PPA HPPA)%_function_scope 
  l l0
list_all_all_forall is transparent
Expands to: Constant nested_eliminators.SortPoly.list_all_all_forall
Declared in library nested_eliminators, line 366, characters 2-116
MRT_ind@{} :
forall P : MRT -> Prop,
(forall l : list@{Type ; Set Set} MRT,
 list_all@{Type Prop ; Set Set Set} MRT P l -> P (MRTnode l)) ->
forall m : MRT, P m

MRT_ind is universe polymorphic
Arguments MRT_ind (P MRTnode)%_function_scope m
MRT_ind is transparent
Expands to: Constant nested_eliminators.SortPoly.MRT_ind
Declared in library nested_eliminators, line 376, characters 2-55
SRT_sind@{u u0} :
forall P : SRT@{u} -> SProp,
(forall l : list@{SProp ; u u} SRT@{u},
 list_all@{SProp SProp ; u u u0} SRT@{u} P l -> P (SRTnode@{u} l)) ->
forall s : SRT@{u}, P s
(* u u0 |=  *)

SRT_sind is universe polymorphic
Arguments SRT_sind (P SRTnode)%_function_scope s
SRT_sind is transparent
Expands to: Constant nested_eliminators.SortPoly.SRT_sind
Declared in library nested_eliminators, line 381, characters 2-57
File "./output/nested_eliminators.v", line 400, characters 2-60:
The command has indeed failed with message:
MRT is nested using list. No scheme for list is registered as All.
[register-all,automation,default]
MRT_ind :
forall P : MRT -> Prop,
(forall l : list MRT, P (MRTnode l)) -> forall m : MRT, P m

MRT_ind is not universe polymorphic
Arguments MRT_ind (P MRTnode)%_function_scope m
MRT_ind is transparent
Expands to: Constant nested_eliminators.TestWarning.MRT_ind
Declared in library nested_eliminators, line 405, characters 2-55
