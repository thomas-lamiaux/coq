File "./output/nested_eliminators.v", line 34, characters 2-69:
Warning: Notation "_ :: _" was already used in scope list_scope.
[notation-overridden,parsing,default]
MRT_ind :
forall P : MRT -> Prop,
(forall l : list MRT, list_all@{Prop ; Set Set} MRT P l -> P (MRTnode l)) ->
forall m : MRT, P m

MRT_ind is not universe polymorphic
Arguments MRT_ind (P MRTnode)%_function_scope m
MRT_ind is transparent
Expands to: Constant nested_eliminators.Template.MRT_ind
Declared in library nested_eliminators, line 53, characters 2-55
RoseTree_ind :
forall (A : Type@{RoseTree_ind.u0}) (P : RoseTree A -> Prop),
(forall a : A, P (RTleaf A a)) ->
(forall l : list (RoseTree A),
 list_all@{Prop ; Set RoseTree_ind.u1} (RoseTree A) P l -> P (RTnode A l)) ->
forall r : RoseTree A, P r

RoseTree_ind is not universe polymorphic
Arguments RoseTree_ind A%_type_scope (P RTleaf RTnode)%_function_scope r
RoseTree_ind is transparent
Expands to: Constant nested_eliminators.Template.RoseTree_ind
Declared in library nested_eliminators, line 58, characters 2-113
RoseRoseTree_ind :
forall (A : Type@{RoseRoseTree_ind.u0}) (P : RoseRoseTree A -> Prop),
(forall a : A, P (Nleaf A a)) ->
(forall p : list (list (RoseRoseTree A)),
 list_all@{Type ; RoseRoseTree_ind.u1 RoseRoseTree_ind.u1}
   (list (RoseRoseTree A))
   (list_all@{Prop ; Set RoseRoseTree_ind.u1} (RoseRoseTree A) P) p ->
 P (Nnode A p)) ->
forall r : RoseRoseTree A, P r

RoseRoseTree_ind is not universe polymorphic
Arguments RoseRoseTree_ind A%_type_scope (P Nleaf Nnode)%_function_scope r
RoseRoseTree_ind is transparent
Expands to: Constant nested_eliminators.Template.RoseRoseTree_ind
Declared in library nested_eliminators, line 64, characters 2-136
ArrowTree1_ind :
forall (A : Type@{ArrowTree1_ind.u0}) (P : ArrowTree1 A -> Prop),
(forall a : A, P (ATleaf1 A a)) ->
(forall l : bool -> list (ArrowTree1 A),
 (forall H : bool,
  list_all@{Prop ; Set ArrowTree1_ind.u1} (ArrowTree1 A) P (l H)) ->
 P (ATnode1 A l)) ->
forall a : ArrowTree1 A, P a

ArrowTree1_ind is not universe polymorphic
Arguments ArrowTree1_ind A%_type_scope (P ATleaf1 ATnode1)%_function_scope a
ArrowTree1_ind is transparent
Expands to: Constant nested_eliminators.Template.ArrowTree1_ind
Declared in library nested_eliminators, line 70, characters 2-133
ArrowTree2_ind :
forall (A : Type@{ArrowTree2_ind.u0}) (P : ArrowTree2 A -> Prop),
(forall a : A, P (ATleaf2 A a)) ->
(forall l : list (nat -> ArrowTree2 A),
 list_all@{Prop ; Set ArrowTree2_ind.u1} (nat -> ArrowTree2 A)
   (fun H : nat -> ArrowTree2 A => forall H0 : nat, P (H H0)) l ->
 P (ATnode2 A l)) ->
forall a : ArrowTree2 A, P a

ArrowTree2_ind is not universe polymorphic
Arguments ArrowTree2_ind A%_type_scope (P ATleaf2 ATnode2)%_function_scope a
ArrowTree2_ind is transparent
Expands to: Constant nested_eliminators.Template.ArrowTree2_ind
Declared in library nested_eliminators, line 76, characters 2-130
ArrowTree3_ind :
forall (A : Type@{ArrowTree3_ind.u0}) (P : ArrowTree3 A -> Prop),
(forall a : A, P (ATleaf3 A a)) ->
(forall l : bool -> list (nat -> ArrowTree3 A),
 (forall H : bool,
  list_all@{Prop ; Set ArrowTree3_ind.u1} (nat -> ArrowTree3 A)
    (fun H0 : nat -> ArrowTree3 A => forall H1 : nat, P (H0 H1)) 
    (l H)) ->
 P (ATnode3 A l)) ->
forall a : ArrowTree3 A, P a

ArrowTree3_ind is not universe polymorphic
Arguments ArrowTree3_ind A%_type_scope (P ATleaf3 ATnode3)%_function_scope a
ArrowTree3_ind is transparent
Expands to: Constant nested_eliminators.Template.ArrowTree3_ind
Declared in library nested_eliminators, line 82, characters 2-140
PairTree_ind :
forall (A : Type@{PairTree_ind.u0}) (P : PairTree A -> Prop),
(forall a : A, P (Pleaf A a)) ->
(forall p : prod (PairTree A) (PairTree A),
 prod_all@{Prop Prop ; Set Set PairTree_ind.u1 PairTree_ind.u1} 
   (PairTree A) P (PairTree A) P p ->
 P (Pnode A p)) ->
forall p : PairTree A, P p

PairTree_ind is not universe polymorphic
Arguments PairTree_ind A%_type_scope (P Pleaf Pnode)%_function_scope p
PairTree_ind is transparent
Expands to: Constant nested_eliminators.Template.PairTree_ind
Declared in library nested_eliminators, line 109, characters 2-124
LeftTree_ind :
forall (A : Type@{LeftTree_ind.u0}) (P : LeftTree A -> Prop),
(forall a : A, P (Lleaf A a)) ->
(forall p : prod (LeftTree A) nat,
 prod_all@{Prop Type ; Set Set LeftTree_ind.u1 Set} 
   (LeftTree A) P nat (fun _ : nat => unit) p ->
 P (Lnode A p)) ->
forall l : LeftTree A, P l

LeftTree_ind is not universe polymorphic
Arguments LeftTree_ind A%_type_scope (P Lleaf Lnode)%_function_scope l
LeftTree_ind is transparent
Expands to: Constant
            nested_eliminators.Template.AutoGeneratedScheme.LeftTree_ind
Declared in library nested_eliminators, line 117, characters 4-121
LeftTree_ind :
forall (A : Type@{LeftTree_ind.u0}) (P : LeftTree A -> Prop),
(forall a : A, P (Lleaf A a)) ->
(forall p : prod (LeftTree A) nat,
 prod_all@{Type Type ; Set Set LeftTree_ind.u1 Set} 
   (LeftTree A) P nat (fun _ : nat => unit) p ->
 P (Lnode A p)) ->
forall l : LeftTree A, P l

LeftTree_ind is not universe polymorphic
Arguments LeftTree_ind A%_type_scope (P Lleaf Lnode)%_function_scope l
LeftTree_ind is transparent
Expands to: Constant nested_eliminators.Template.Scheme.LeftTree_ind
Declared in library nested_eliminators, line 133, characters 4-44
LeftTree_ind :
forall (A : Type@{LeftTree_ind.u0}) (P : LeftTree A -> Prop),
(forall a : A, P (Lleaf A a)) ->
(forall p : prod (LeftTree A) nat,
 prod_all_10@{Prop ; Set LeftTree_ind.u1 Set} (LeftTree A) P nat p ->
 P (Lnode A p)) ->
forall l : LeftTree A, P l

LeftTree_ind is not universe polymorphic
Arguments LeftTree_ind A%_type_scope (P Lleaf Lnode)%_function_scope l
LeftTree_ind is transparent
Expands to: Constant nested_eliminators.Template.PartialAll.LeftTree_ind
Declared in library nested_eliminators, line 155, characters 4-121
RightTree_ind :
forall (A : Type@{RightTree_ind.u0}) (P : RightTree A -> Prop),
(forall a : A, P (Rleaf A a)) ->
(forall p : prod nat (RightTree A),
 prod_all@{Type Prop ; Set Set Set RightTree_ind.u1} nat
   (fun _ : nat => unit) (RightTree A) P p ->
 P (Rnode A p)) ->
forall r : RightTree A, P r

RightTree_ind is not universe polymorphic
Arguments RightTree_ind A%_type_scope (P Rleaf Rnode)%_function_scope r
RightTree_ind is transparent
Expands to: Constant nested_eliminators.Template.RightTree_ind
Declared in library nested_eliminators, line 163, characters 2-119
VecTree_ind :
forall (A : Type@{VecTree_ind.u0}) (P : VecTree A -> Prop),
(forall a : A, P (VNleaf A a)) ->
(forall (n : nat) (p : vec (VecTree A) n),
 vec_all@{Prop ; Set VecTree_ind.u1} (VecTree A) P n p -> P (VNnode A n p)) ->
forall v : VecTree A, P v

VecTree_ind is not universe polymorphic
Arguments VecTree_ind A%_type_scope (P VNleaf VNnode)%_function_scope v
VecTree_ind is transparent
Expands to: Constant nested_eliminators.Template.VecTree_ind
Declared in library nested_eliminators, line 192, characters 2-112
typing_ind :
forall (A : Type@{typing_ind.u0}) (B : Type@{typing_ind.u1})
  (P : forall (n : nat) (a : A) (b : B), typing A B n a b -> Prop),
(forall (n : nat) (a : A) (b : B), P n a b (typ_nil A B n a b)) ->
(forall (n : nat) (a : A) (b : B) (lA : list A) (lB : list B)
   (a0 : All2i A B (fun n0 : nat => typing A B n0) n lA lB),
 All2i_all@{Prop ; Set typing_ind.u0 typing_ind.u1 typing_ind.u2} A B
   (fun (n0 : nat) (H : A) (H0 : B) => typing A B n0 H H0) P n lA lB a0 ->
 P n a b (typ_cons A B n a b lA lB a0)) ->
forall (n : nat) (a : A) (b : B) (t : typing A B n a b), P n a b t

typing_ind is not universe polymorphic
Arguments typing_ind (A B)%_type_scope (P typ_nil typ_cons)%_function_scope 
  n a b t
typing_ind is transparent
Expands to: Constant nested_eliminators.Template.typing_ind
Declared in library nested_eliminators, line 234, characters 2-218
triv_All2_bis_ind :
forall P : triv_All2_bis -> Prop,
(forall
   a : All2i_bis bool bool triv_All2_bis (fun (_ : nat) (_ _ : bool) => nat)
         zero nil nil,
 All2i_bis_all@{Prop Type ; Set Set Set Set Set Set} bool bool triv_All2_bis
   P (fun (_ : nat) (_ _ : bool) => nat)
   (fun (_ : nat) (_ _ : bool) (_ : nat) => unit) zero nil nil a ->
 P (ctriv_All2_bis a)) ->
forall t : triv_All2_bis, P t

triv_All2_bis_ind is not universe polymorphic
Arguments triv_All2_bis_ind (P ctriv_All2_bis)%_function_scope t
triv_All2_bis_ind is transparent
Expands to: Constant nested_eliminators.Template.triv_All2_bis_ind
Declared in library nested_eliminators, line 277, characters 2-176
File "./output/nested_eliminators.v", line 300, characters 2-69:
Warning: Notation "_ :: _" was already used in scope list_scope.
[notation-overridden,parsing,default]
MRT_ind@{} :
forall P : MRT -> Prop,
(forall l : list@{Set} MRT,
 list_all@{Prop ; Set Set} MRT P l -> P (MRTnode l)) ->
forall m : MRT, P m

MRT_ind is universe polymorphic
Arguments MRT_ind (P MRTnode)%_function_scope m
MRT_ind is transparent
Expands to: Constant nested_eliminators.UnivPoly.MRT_ind
Declared in library nested_eliminators, line 319, characters 2-55
RoseTree_ind@{u u0} :
forall (A : Type@{u}) (P : RoseTree@{u u0} A -> Prop),
(forall a : A, P (RTleaf@{u u0} A a)) ->
(forall l : list@{u0} (RoseTree@{u u0} A),
 list_all@{Prop ; Set u0} (RoseTree@{u u0} A) P l -> P (RTnode@{u u0} A l)) ->
forall r : RoseTree@{u u0} A, P r
(* u u0 |= u <= u0 *)

RoseTree_ind is universe polymorphic
Arguments RoseTree_ind A%_type_scope (P RTleaf RTnode)%_function_scope r
RoseTree_ind is transparent
Expands to: Constant nested_eliminators.UnivPoly.RoseTree_ind
Declared in library nested_eliminators, line 324, characters 2-113
ArrowTree3_ind@{u u0} :
forall (A : Type@{u}) (P : ArrowTree3@{u u0} A -> Prop),
(forall a : A, P (ATleaf3@{u u0} A a)) ->
(forall l : bool -> list@{u0} (nat -> ArrowTree3@{u u0} A),
 (forall H : bool,
  list_all@{Prop ; Set u0} (nat -> ArrowTree3@{u u0} A)
    (fun H0 : nat -> ArrowTree3@{u u0} A => forall H1 : nat, P (H0 H1)) 
    (l H)) ->
 P (ATnode3@{u u0} A l)) ->
forall a : ArrowTree3@{u u0} A, P a
(* u u0 |= u <= u0 *)

ArrowTree3_ind is universe polymorphic
Arguments ArrowTree3_ind A%_type_scope (P ATleaf3 ATnode3)%_function_scope a
ArrowTree3_ind is transparent
Expands to: Constant nested_eliminators.UnivPoly.ArrowTree3_ind
Declared in library nested_eliminators, line 334, characters 2-140
File "./output/nested_eliminators.v", line 355, characters 2-69:
Warning: Notation "_ :: _" was already used in scope list_scope.
[notation-overridden,parsing,default]
MRT_ind@{} :
forall P : MRT -> Prop,
(forall l : list@{Type ; Set Set} MRT,
 list_all@{Type Prop ; Set Set Set} MRT P l -> P (MRTnode l)) ->
forall m : MRT, P m

MRT_ind is universe polymorphic
Arguments MRT_ind (P MRTnode)%_function_scope m
MRT_ind is transparent
Expands to: Constant nested_eliminators.SortPoly.MRT_ind
Declared in library nested_eliminators, line 372, characters 2-55
SRT_sind@{u u0 u1} :
forall P : SRT@{u} -> SProp,
(forall l : list@{SProp ; u u} SRT@{u},
 list_all@{SProp SProp ; u u0 u1} SRT@{u} P l -> P (SRTnode@{u} l)) ->
forall s : SRT@{u}, P s
(* u u0 u1 |= u <= u1
              u0 <= u1 *)

SRT_sind is universe polymorphic
Arguments SRT_sind (P SRTnode)%_function_scope s
SRT_sind is transparent
Expands to: Constant nested_eliminators.SortPoly.SRT_sind
Declared in library nested_eliminators, line 377, characters 2-57
File "./output/nested_eliminators.v", line 394, characters 2-60:
The command has indeed failed with message:
MRT is nested using list. No scheme for list is registered as All.
[register-all,automation,default]
MRT_ind :
forall P : MRT -> Prop,
(forall l : list MRT, P (MRTnode l)) -> forall m : MRT, P m

MRT_ind is not universe polymorphic
Arguments MRT_ind (P MRTnode)%_function_scope m
MRT_ind is transparent
Expands to: Constant nested_eliminators.TestWarning.MRT_ind
Declared in library nested_eliminators, line 399, characters 2-55
